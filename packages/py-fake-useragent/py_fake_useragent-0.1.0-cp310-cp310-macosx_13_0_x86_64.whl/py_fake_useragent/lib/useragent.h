/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package github.com/imbecility/go-fake-useragent/cmd/c-wrapper */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
extern size_t _GoStringLen(_GoString_ s);
extern const char *_GoStringPtr(_GoString_ s);
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 9 "main.go"

#include <stdlib.h>
#include <stdbool.h>
#include <stddef.h>

// тип C коллбэка для передачи логов из Go в Python: принимает строку (char*) и ничего не возвращает
typedef void (*log_callback_f)(char*);

// статическая inline-функция для безопасного вызова коллбэка через проверку NULL в С
// (проще, чем обработка нулевого указателя в Go)
static inline void call_log_callback(log_callback_f f, char* msg) {
   if (f != NULL) {
	   f(msg);
   }
}

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#if !defined(__cplusplus) || _MSVC_LANG <= 201402L
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
#include <complex>
typedef std::complex<float> GoComplex64;
typedef std::complex<double> GoComplex128;
#endif
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// Initialize экспортируется в C, однократно инициализирует глобальный генератор user-agent'ов
//
// потокобезопасна благодаря `sync.Once`
//
// параметры:
//   - useCache: C.bool (true), если нужно использовать дисковый кеш
//   - cacheTTLDays: C.int, время жизни (TTL) кеша в днях
//
// возвращает:
//   - C.int: 0 (ErrSuccess) в случае успеха, или код ошибки
//
extern int Initialize(_Bool useCache, int cacheTTLDays);

// Shutdown экспортируется в C, корректно завершает работу библиотеки,
// отключает логирование и дожидается завершения обработки всех оставшихся логов,
// потокобезопасна благодаря `sync.Once`.
//
extern void Shutdown(void);

// SetLoggerCallback экспортируется в C, устанавливает функцию обратного вызова для получения логов.
//
// параметры:
//   - callback: указатель на функцию типа `log_callback_f` в Python.
//     NULL - отключает
//
extern void SetLoggerCallback(log_callback_f callback);

// GetDroppedLogs экспортируется в C, возвращает количество отброшенных из-за переполнения сообщений лога
//
// возвращает:
//   - C.ulonglong: количество отброшенных логов
//
extern unsigned long long GetDroppedLogs(void);

// GetRandomUA экспортируется в C, генерирует случайный User-Agent
// использует паттерн двойного вызова с помощью copyToBuffer
//
// параметры:
//   - buffer: указатель на буфер для записи строки User-Agent
//   - length: размер буфера.
//
// возвращает:
//   - C.int: код ошибки, требуемый размер буфера или количество скопированных байт
//
extern int GetRandomUA(char* buffer, size_t length);

// GetHeaders экспортируется в C, генерирует заголовки для HTTP-запроса, возвращает их в виде JSON-строки
//
// параметры:
//   - url: URL, для которого генерируются заголовки или NULL
//   - buffer: указатель на буфер для записи JSON-строки
//   - length: размер буфера
//
// возвращает:
//   - C.int: код ошибки, требуемый размер буфера или количество скопированных байт.
//
extern int GetHeaders(char* url, char* buffer, size_t length);

// GetCrawlerHeaders экспортируется в C, генерирует заголовки под поискового робота, возвращает их в виде JSON-строки
//
// параметры:
//   - crawlerType: тип робота (0: google, 1: bing, 2: yandex)
//   - buffer: указатель на буфер для записи JSON-строки
//   - length: размер буфера
//
// возвращает:
//   - C.int: код ошибки, требуемый размер буфера или количество скопированных байт
//
extern int GetCrawlerHeaders(int crawlerType, char* buffer, size_t length);

#ifdef __cplusplus
}
#endif
