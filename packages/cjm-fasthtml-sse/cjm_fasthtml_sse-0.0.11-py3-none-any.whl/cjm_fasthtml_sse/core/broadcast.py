"""Broadcasting infrastructure for SSE cross-tab synchronization"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/broadcast.ipynb.

# %% auto 0
__all__ = ['BroadcastMessage', 'BroadcastManager', 'create_broadcast_endpoint', 'create_broadcast_handler',
           'setup_broadcast_routes']

# %% ../../nbs/core/broadcast.ipynb 3
import asyncio
from typing import Dict, Set, Any, Optional, Callable, Deque
from collections import deque
from datetime import datetime
import json
from dataclasses import dataclass, field, asdict
from fasthtml.common import EventStream, sse_message, FT

# %% ../../nbs/core/broadcast.ipynb 5
@dataclass
class BroadcastMessage:
    """Standard broadcast message format for SSE communication"""
    type: str
    data: Dict[str, Any]
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(
        self
    ) -> Dict[str, Any]:  # Dictionary representation of the message
        """Convert message to dictionary format"""
        return asdict(self)
    
    def to_json(
        self
    ) -> str:  # JSON string representation of the message
        """Convert message to JSON string"""
        return json.dumps(self.to_dict())
    
    def to_sse(
        self,
        event_type: Optional[str] = 'message'  # SSE event type for the message
    ) -> str:  # SSE formatted message string
        """Convert to SSE message format using FastHTML's sse_message"""
        if isinstance(self.data, FT):
            return sse_message(self.data, event=event_type)
        else:
            return f"event: {event_type}\ndata: {self.to_json()}\n\n"

# %% ../../nbs/core/broadcast.ipynb 6
class BroadcastManager:
    """Manages SSE broadcast connections across multiple tabs/clients"""
    
    def __init__(self, 
                 max_queue_size: int = 100,  # Maximum size for each connection's message queue
                 history_limit: int = 50,  # Number of recent messages to keep in history
                 queue_timeout: float = 0.1,  # Timeout for queue operations in seconds
                 debug: bool = False # Enable debug logging
                ):
        """
        Initialize the broadcast manager.
        """
        self.connections: Dict[str, asyncio.Queue] = {}
        self.connection_metadata: Dict[str, Dict[str, Any]] = {}
        self.history: Deque[BroadcastMessage] = deque(maxlen=history_limit)
        self.lock = asyncio.Lock()
        self.max_queue_size = max_queue_size
        self.queue_timeout = queue_timeout
        self.debug = debug
        self._connection_counter = 0
    
    async def register(self, 
                      connection_id: Optional[str] = None,  # Optional ID for the connection (auto-generated if not provided)
                      metadata: Optional[Dict[str, Any]] = None # Optional metadata for the connection
                      ) -> tuple[str, asyncio.Queue]: # Tuple of (connection_id, queue)
        """
        Register a new connection and return its queue.
        """
        queue = asyncio.Queue(maxsize=self.max_queue_size)
        
        async with self.lock:
            if connection_id is None:
                self._connection_counter += 1
                connection_id = f"conn_{self._connection_counter}"
            
            self.connections[connection_id] = queue
            self.connection_metadata[connection_id] = metadata or {}
            self.connection_metadata[connection_id]['connected_at'] = datetime.now().isoformat()
            
            if self.debug:
                print(f"[BroadcastManager] Registered connection: {connection_id}")
        
        return connection_id, queue
    
    async def unregister(
        self,
        connection_id: str  # ID of the connection to unregister
    ):
        """Unregister a connection."""
        async with self.lock:
            if connection_id in self.connections:
                del self.connections[connection_id]
                del self.connection_metadata[connection_id]
                
                if self.debug:
                    print(f"[BroadcastManager] Unregistered connection: {connection_id}")
    
    async def broadcast(self, 
                       message_type: str,  # Type of the message
                       data: Dict[str, Any], # Message data
                       metadata: Optional[Dict[str, Any]] = None, # Optional metadata
                       exclude: Optional[Set[str]] = None # Set of connection IDs to exclude from broadcast
                       ) -> int: # Number of successful broadcasts
        """
        Broadcast a message to all connected clients.
        """
        message = BroadcastMessage(type=message_type, data=data, metadata=metadata)
        self.history.append(message)
        
        exclude = exclude or set()
        successful = 0
        
        async with self.lock:
            disconnected = set()
            
            for conn_id, queue in self.connections.items():
                if conn_id in exclude:
                    continue
                    
                try:
                    await asyncio.wait_for(
                        queue.put(message),
                        timeout=self.queue_timeout
                    )
                    successful += 1
                except (asyncio.TimeoutError, asyncio.QueueFull):
                    disconnected.add(conn_id)
                    if self.debug:
                        print(f"[BroadcastManager] Failed to send to {conn_id}")
            
            # Clean up disconnected clients
            for conn_id in disconnected:
                del self.connections[conn_id]
                del self.connection_metadata[conn_id]
        
        if self.debug:
            print(f"[BroadcastManager] Broadcast to {successful} clients")
        
        return successful
    
    async def send_to(self,
                     connection_id: str,  # Target connection ID
                     message_type: str,  # Type of the message
                     data: Dict[str, Any], # Message data
                     metadata: Optional[Dict[str, Any]] = None # Optional metadata
                     ) -> bool: # True if successful, False otherwise
        """
        Send a message to a specific connection.
        """
        if connection_id not in self.connections:
            return False
        
        message = BroadcastMessage(type=message_type, data=data, metadata=metadata)
        
        try:
            await asyncio.wait_for(
                self.connections[connection_id].put(message),
                timeout=self.queue_timeout
            )
            return True
        except (asyncio.TimeoutError, asyncio.QueueFull):
            await self.unregister(connection_id)
            return False
    
    def get_connection_count(
        self
    ) -> int:  # Number of active connections
        """Get the number of active connections."""
        return len(self.connections)
    
    def get_history(
        self,
        limit: Optional[int] = None  # Maximum number of messages to return
    ) -> list[BroadcastMessage]:  # List of broadcast messages from history
        """Get broadcast history."""
        if limit:
            return list(self.history)[-limit:]
        return list(self.history)

# %% ../../nbs/core/broadcast.ipynb 8
async def create_broadcast_endpoint(manager: BroadcastManager,
                                   connection_id: Optional[str] = None,  # Optional connection ID
                                   heartbeat_interval: float = 30.0,  # Interval for sending heartbeat messages
                                   send_history: bool = False,  # Whether to send recent history on connection
                                   history_limit: int = 10) -> EventStream:
    """Create an SSE endpoint for broadcasting."""
    async def stream():
        """Generate SSE stream events for the broadcast endpoint."""
        conn_id, queue = await manager.register(connection_id)
        
        try:
            # Send connection confirmation
            yield f": Connected as {conn_id} (active: {manager.get_connection_count()})\n\n"
            
            # Send history if requested
            if send_history:
                history = manager.get_history(history_limit)
                for msg in history:
                    yield f"event: history\ndata: {msg.to_json()}\n\n"
            
            # Main message loop
            while True:
                try:
                    # Wait for message with timeout for heartbeat
                    message = await asyncio.wait_for(
                        queue.get(),
                        timeout=heartbeat_interval
                    )
                    
                    # Send the message
                    yield message.to_sse()
                    
                except asyncio.TimeoutError:
                    # Send heartbeat
                    yield f": heartbeat {datetime.now().isoformat()}\n\n"
                    
        except asyncio.CancelledError:
            pass
        finally:
            await manager.unregister(conn_id)
    
    return EventStream(stream())

# %% ../../nbs/core/broadcast.ipynb 9
def create_broadcast_handler(manager: BroadcastManager,
                            element_builder: Optional[Callable] = None):
    """Create a broadcast handler function that can be used with FastHTML routes."""
    async def handler(
        connection_id: Optional[str] = None  # Optional connection ID
    ):
        """Handle SSE broadcast connection."""
        async def stream():
            """Generate SSE stream for the connection."""
            conn_id, queue = await manager.register(connection_id)
            
            try:
                yield f": Connected ({manager.get_connection_count()} active)\n\n"
                
                while True:
                    try:
                        message = await asyncio.wait_for(queue.get(), timeout=30.0)
                        
                        if element_builder:
                            # Use custom element builder if provided
                            elements = element_builder(message.type, message.data)
                            yield sse_message(elements)
                        else:
                            # Default to sending raw message
                            yield message.to_sse()
                            
                    except asyncio.TimeoutError:
                        yield f": heartbeat\n\n"
                        
            finally:
                await manager.unregister(conn_id)
        
        return EventStream(stream())
    
    return handler

# %% ../../nbs/core/broadcast.ipynb 10
def setup_broadcast_routes(app, 
                          manager: BroadcastManager,  # The broadcast manager instance
                          prefix: str = "/sse",  # URL prefix for SSE endpoints
                          element_builder: Optional[Callable] = None):
    """Setup broadcast routes on a FastHTML app."""
    handler = create_broadcast_handler(manager, element_builder)
    
    # Register the route
    @app.route(f"{prefix}/broadcast")
    async def broadcast_endpoint(
        connection_id: Optional[str] = None  # Optional connection ID for the SSE connection
    ):
        """SSE broadcast endpoint for client connections."""
        return await handler(connection_id)
    
    # Add a status endpoint
    @app.route(f"{prefix}/status")
    def broadcast_status():
        return {
            "connections": manager.get_connection_count(),
            "history_size": len(manager.history)
        }
