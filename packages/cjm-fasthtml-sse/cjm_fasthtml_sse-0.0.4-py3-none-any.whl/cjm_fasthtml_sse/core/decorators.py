"""Route decorators and utilities for FastHTML SSE endpoints"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/decorators.ipynb.

# %% auto 0
__all__ = ['sse_endpoint', 'broadcast_action', 'sse_generator_endpoint']

# %% ../../nbs/core/decorators.ipynb 3
import asyncio
import functools
from typing import Optional, Callable, Any, Dict, Union, AsyncIterator, AsyncGenerator
from inspect import signature, iscoroutinefunction

# Import EventStream from FastHTML (it's a function that creates StreamingResponse)
try:
    from fasthtml.common import EventStream
    from starlette.responses import StreamingResponse
except ImportError:
    # Fallback if FastHTML not installed
    from starlette.responses import StreamingResponse
    def EventStream(
        s: AsyncGenerator  # Async generator that yields SSE formatted strings
    ):
        "Create a text/event-stream response from `s`"
        return StreamingResponse(s, media_type="text/event-stream")

# Import broadcast and streaming components
from cjm_fasthtml_sse.core.broadcast import (
    SSEBroadcastManager,
    BroadcastMessage
)
from cjm_fasthtml_sse.core.streaming import (
    sse_broadcast_stream,
    SSEStreamConfig,
    format_sse_message,
    sse_generator
)

# %% ../../nbs/core/decorators.ipynb 5
def sse_endpoint(
    broadcast_manager: Optional[SSEBroadcastManager] = None,  # Optional SSEBroadcastManager for automatic broadcasting
    config: Optional[SSEStreamConfig] = None,  # Optional SSEStreamConfig for stream configuration
    message_filter: Optional[Callable[[BroadcastMessage], bool]] = None,
    client_metadata_fn: Optional[Callable[..., Dict[str, Any]]] = None
):
    """Decorator for creating SSE endpoints with optional broadcast integration. This decorator can work in two modes: 1. With broadcast_manager: Automatically connects to broadcast stream 2. Without broadcast_manager: Wraps custom async generator functions"""
    def decorator(
        func: Callable  # The endpoint function to decorate
    ):
        """Apply SSE endpoint decoration to a function"""
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            """Wrapped SSE endpoint handler"""
            # Extract client metadata if function provided
            client_metadata = None
            if client_metadata_fn:
                client_metadata = client_metadata_fn(*args, **kwargs)
            
            # Mode 1: Use broadcast manager
            if broadcast_manager:
                # Call the original function to allow for any setup
                if iscoroutinefunction(func):
                    result = await func(*args, **kwargs)
                else:
                    result = func(*args, **kwargs)
                
                # If function returns a filter, use it
                filter_fn = message_filter
                if callable(result):
                    filter_fn = result
                
                # Create broadcast stream
                generator = sse_broadcast_stream(
                    broadcast_manager,
                    client_metadata=client_metadata,
                    config=config,
                    message_filter=filter_fn
                )
                
                return EventStream(generator)
            
            # Mode 2: Wrap custom generator
            else:
                # Get the generator from the function
                if iscoroutinefunction(func):
                    gen = await func(*args, **kwargs)
                else:
                    gen = func(*args, **kwargs)
                
                # If it's already an async generator, format messages
                async def format_generator():
                    """Format and yield SSE messages from generator"""
                    if hasattr(gen, '__aiter__'):
                        async for data in gen:
                            if isinstance(data, str):
                                yield data  # Already formatted
                            else:
                                yield format_sse_message(data)
                    else:
                        # Not a generator, create one
                        yield format_sse_message(gen)
                
                return EventStream(format_generator())
        
        return wrapper
    return decorator

# %% ../../nbs/core/decorators.ipynb 7
def broadcast_action(
    manager: SSEBroadcastManager,  # SSEBroadcastManager to broadcast through
    event_type: Optional[str] = None,  # Event type to broadcast (defaults to function name)
    extract_data: Optional[Callable[..., Dict[str, Any]]] = None,
    broadcast_before: bool = False,  # Broadcast before executing function
    broadcast_after: bool = True,  # Broadcast after executing function
    include_result: bool = True  # Include function result in broadcast data
):
    """Decorator that broadcasts events when actions occur. This decorator automatically broadcasts SSE messages when the decorated function is called, useful for notifying clients of state changes."""
    def decorator(
        func: Callable  # The function to decorate with broadcast capability
    ):
        """Apply broadcast action decoration to a function"""
        # Use function name as default event type
        nonlocal event_type
        if event_type is None:
            event_type = func.__name__
        
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs):
            """Async wrapper that handles broadcasting for async functions"""
            # Extract data for broadcast
            data = {}
            if extract_data:
                data = extract_data(*args, **kwargs)
            
            # Broadcast before execution
            if broadcast_before:
                await manager.broadcast(
                    f"{event_type}_started",
                    data
                )
            
            # Execute the function
            try:
                result = await func(*args, **kwargs)
                
                # Broadcast after execution
                if broadcast_after:
                    broadcast_data = data.copy()
                    if include_result and result is not None:
                        if isinstance(result, dict):
                            broadcast_data.update(result)
                        else:
                            broadcast_data['result'] = result
                    
                    await manager.broadcast(
                        event_type,
                        broadcast_data
                    )
                
                return result
                
            except Exception as e:
                # Broadcast error
                await manager.broadcast(
                    f"{event_type}_error",
                    {"error": str(e), **data}
                )
                raise
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs):
            """Sync wrapper that handles broadcasting for sync functions"""
            # For sync functions, run in event loop
            loop = asyncio.get_event_loop()
            
            # Extract data for broadcast
            data = {}
            if extract_data:
                data = extract_data(*args, **kwargs)
            
            # Broadcast before execution
            if broadcast_before:
                loop.run_until_complete(
                    manager.broadcast(f"{event_type}_started", data)
                )
            
            # Execute the function
            try:
                result = func(*args, **kwargs)
                
                # Broadcast after execution
                if broadcast_after:
                    broadcast_data = data.copy()
                    if include_result and result is not None:
                        if isinstance(result, dict):
                            broadcast_data.update(result)
                        else:
                            broadcast_data['result'] = result
                    
                    loop.run_until_complete(
                        manager.broadcast(event_type, broadcast_data)
                    )
                
                return result
                
            except Exception as e:
                # Broadcast error
                loop.run_until_complete(
                    manager.broadcast(
                        f"{event_type}_error",
                        {"error": str(e), **data}
                    )
                )
                raise
        
        # Return appropriate wrapper
        if iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
    
    return decorator

# %% ../../nbs/core/decorators.ipynb 9
def sse_generator_endpoint(
    interval: float = 1.0,  # Seconds between data checks
    event_type: Optional[str] = None,  # Optional event type for messages
    heartbeat: Optional[float] = 30.0  # Heartbeat interval in seconds
):
    """Decorator for creating simple SSE endpoints from data functions. This decorator converts a function that returns data into an SSE streaming endpoint."""
    def decorator(
        func: Callable  # The data function to convert to SSE endpoint
    ):
        """Apply SSE generator decoration to a data function"""
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            """Wrapped SSE generator endpoint handler"""
            # Create data source function
            def data_source():
                """Get data from the decorated function"""
                return func(*args, **kwargs)
            
            # Create SSE generator
            generator = sse_generator(
                data_source,
                interval=interval,
                event_type=event_type,
                heartbeat=heartbeat
            )
            
            return EventStream(generator)
        
        return wrapper
    return decorator
