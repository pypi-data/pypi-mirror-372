"""SSE response builders for complex UI updates"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/response.ipynb.

# %% auto 0
__all__ = ['UpdateRule', 'SSEResponseBuilder', 'create_conditional_response', 'create_state_response_builder']

# %% ../../nbs/core/response.ipynb 3
from typing import Dict, List, Any, Optional, Callable, Union, Tuple
from dataclasses import dataclass, field
from fasthtml.common import Div, FT, sse_message
from .streaming import OOBStreamBuilder

# %% ../../nbs/core/response.ipynb 5
@dataclass
class UpdateRule:
    """Rule for conditional element updates"""
    condition: Callable  # Function that returns True if rule should apply
    builder: Callable  # Function that builds the element(s)
    target_id: Optional[str] = None  # Target element ID for OOB swap
    swap_mode: str = "innerHTML"  # Swap mode
    priority: int = 0  # Higher priority rules are evaluated first

# %% ../../nbs/core/response.ipynb 6
class SSEResponseBuilder:
    """Builder for complex SSE responses with conditional updates"""
    
    def __init__(
        self,
        debug: bool = False  # Enable debug logging
    ):
        """Initialize the response builder."""
        self.debug = debug
        self.rules: List[UpdateRule] = []
        self.always_include: List[Callable] = []
        self.context: Dict[str, Any] = {}
    
    def add_rule(
        self,
        condition: Callable,  # Condition function
        builder: Callable,  # Element builder function
        target_id: Optional[str] = None,  # Target ID for OOB
        swap_mode: str = "innerHTML",  # Swap mode
        priority: int = 0  # Rule priority
    ) -> 'SSEResponseBuilder':  # Self for chaining
        """Add a conditional update rule."""
        rule = UpdateRule(
            condition=condition,
            builder=builder,
            target_id=target_id,
            swap_mode=swap_mode,
            priority=priority
        )
        self.rules.append(rule)
        # Sort by priority (highest first)
        self.rules.sort(key=lambda r: r.priority, reverse=True)
        return self
    
    def add_always(
        self,
        builder: Callable  # Element builder that always runs
    ) -> 'SSEResponseBuilder':  # Self for chaining
        """Add a builder that always runs."""
        self.always_include.append(builder)
        return self
    
    def set_context(
        self,
        **kwargs  # Context variables
    ) -> 'SSEResponseBuilder':  # Self for chaining
        """Set context variables for builders."""
        self.context.update(kwargs)
        return self
    
    def build(
        self,
        **kwargs  # Additional context for this build
    ) -> FT:  # Built response
        """Build the response based on rules and context."""
        # Merge contexts
        build_context = {**self.context, **kwargs}
        
        # Use OOBStreamBuilder for clean element construction
        builder = OOBStreamBuilder()
        
        # Always include elements
        for always_builder in self.always_include:
            elements = always_builder(**build_context)
            if elements:
                if isinstance(elements, list):
                    for elem in elements:
                        builder.add_element(elem)
                else:
                    builder.add_element(elements)
        
        # Apply conditional rules
        for rule in self.rules:
            if rule.condition(**build_context):
                elements = rule.builder(**build_context)
                if elements:
                    if isinstance(elements, list):
                        for elem in elements:
                            builder.add_element(
                                elem,
                                target_id=rule.target_id,
                                swap_mode=rule.swap_mode
                            )
                    else:
                        builder.add_element(
                            elements,
                            target_id=rule.target_id,
                            swap_mode=rule.swap_mode
                        )
                
                if self.debug:
                    print(f"[SSEResponseBuilder] Applied rule with priority {rule.priority}")
        
        return builder.build()
    
    def clear_rules(
        self
    ) -> 'SSEResponseBuilder':  # Self for chaining
        """Clear all rules."""
        self.rules = []
        return self
    
    def clear_always(
        self
    ) -> 'SSEResponseBuilder':  # Self for chaining
        """Clear always-include builders."""
        self.always_include = []
        return self

# %% ../../nbs/core/response.ipynb 12
def create_conditional_response(
    conditions: List[Tuple[Callable, Callable]],  # List of (condition, builder) tuples
    always_include: Optional[List[Callable]] = None,  # Builders that always run
    context: Optional[Dict[str, Any]] = None  # Initial context
) -> SSEResponseBuilder:  # Configured response builder
    """Create a response builder with predefined conditions."""
    builder = SSEResponseBuilder()
    
    # Set initial context
    if context:
        builder.set_context(**context)
    
    # Add always-include builders
    if always_include:
        for always_builder in always_include:
            builder.add_always(always_builder)
    
    # Add conditional rules
    for i, (condition, element_builder) in enumerate(conditions):
        builder.add_rule(
            condition=condition,
            builder=element_builder,
            priority=len(conditions) - i  # Higher priority for earlier rules
        )
    
    return builder

# %% ../../nbs/core/response.ipynb 13
def create_state_response_builder(
    state_builders: Dict[str, Callable],  # Mapping of state names to builders
    get_state_fn: Callable,  # Function to determine current state
    default_builder: Optional[Callable] = None  # Default builder if no state matches
) -> SSEResponseBuilder:  # Configured response builder
    """Create a response builder for state-based updates."""
    builder = SSEResponseBuilder()
    
    # Add rules for each state
    for state_name, state_builder in state_builders.items():
        builder.add_rule(
            condition=lambda s=state_name, **ctx: get_state_fn(**ctx) == s,
            builder=state_builder
        )
    
    # Add default if provided
    if default_builder:
        builder.add_rule(
            condition=lambda **ctx: get_state_fn(**ctx) not in state_builders,
            builder=default_builder,
            priority=-1  # Lowest priority
        )
    
    return builder
