"""Manage multiple related SSE streams for a single entity"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/multi_stream.ipynb.

# %% auto 0
__all__ = ['StreamEndpoint', 'MultiStreamManager', 'create_multi_stream_row']

# %% ../../nbs/core/multi_stream.ipynb 3
import asyncio
from typing import Dict, Optional, Any, Callable, List, AsyncGenerator, Union
from dataclasses import dataclass, field
from fasthtml.common import EventStream, sse_message, Div, Span, FT
from .connections import ConnectionRegistry, SSEConnection
from .streaming import SSEStream, StreamConfig, OOBStreamBuilder

# %% ../../nbs/core/multi_stream.ipynb 5
@dataclass
class StreamEndpoint:
    """Configuration for a single SSE stream endpoint"""
    name: str  # Stream name (e.g., 'progress', 'status')
    path_suffix: str  # URL path suffix (e.g., '_progress', '_status')
    data_source: Callable  # Async generator or callable that produces data
    transform_fn: Optional[Callable] = None  # Optional transform function
    config: Optional[StreamConfig] = None  # Stream configuration
    metadata: Dict[str, Any] = field(default_factory=dict)  # Additional metadata

# %% ../../nbs/core/multi_stream.ipynb 6
class MultiStreamManager:
    """Manages multiple related SSE streams for entities"""
    
    def __init__(
        self,
        base_path: str = "/stream",  # Base path for stream endpoints
        connection_registry: Optional[ConnectionRegistry] = None,  # Optional shared registry
        default_config: Optional[StreamConfig] = None,  # Default config for all streams
        debug: bool = False  # Enable debug logging
    ):
        """Initialize the multi-stream manager."""
        self.base_path = base_path
        self.connection_registry = connection_registry or ConnectionRegistry(debug=debug)
        self.default_config = default_config or StreamConfig()
        self.debug = debug
        self.endpoints: Dict[str, StreamEndpoint] = {}
    
    def register_endpoint(
        self,
        endpoint: StreamEndpoint  # Stream endpoint configuration
    ) -> 'MultiStreamManager':  # Self for chaining
        """Register a stream endpoint."""
        self.endpoints[endpoint.name] = endpoint
        if self.debug:
            print(f"[MultiStreamManager] Registered endpoint: {endpoint.name}")
        return self
    
    def create_element(
        self,
        entity_id: str,  # Entity ID (e.g., job_id, user_id)
        stream_name: str,  # Stream name to connect to
        element_id: Optional[str] = None,  # Optional element ID
        wrapper: Optional[Callable] = None,  # Optional wrapper function for the element
        **attrs  # Additional attributes
    ) -> FT:  # HTMX-enabled SSE element
        """Create an SSE-enabled element for a specific stream."""
        endpoint = self.endpoints.get(stream_name)
        if not endpoint:
            raise ValueError(f"Unknown stream: {stream_name}")
        
        path = f"{self.base_path}{endpoint.path_suffix}?id={entity_id}"
        
        sse_attrs = {
            'hx_ext': 'sse',
            'sse_connect': path,
            'sse_swap': 'message'
        }
        
        if element_id:
            sse_attrs['id'] = element_id
        
        sse_attrs.update(attrs)
        
        element = Span(**sse_attrs) if wrapper is None else wrapper(**sse_attrs)
        return element
    
    def create_handler(
        self,
        stream_name: str,  # Stream name
        get_entity_fn: Callable,  # Function to get entity state
        is_active_fn: Callable  # Function to check if entity is active
    ) -> Callable:  # Route handler function
        """Create a route handler for a specific stream."""
        endpoint = self.endpoints.get(stream_name)
        if not endpoint:
            raise ValueError(f"Unknown stream: {stream_name}")
        
        async def handler(id: str):  # Entity ID from query parameter
            """SSE handler for the stream."""
            async def stream():
                # Register connection
                connection = await self.connection_registry.add_connection(
                    conn_type=f"{stream_name}_{id}",
                    metadata={"entity_id": id, "stream": stream_name}
                )
                
                try:
                    # Check if entity is active
                    entity = get_entity_fn(id)
                    if not entity or not is_active_fn(entity):
                        # Send final message and close
                        if endpoint.transform_fn:
                            final_msg = endpoint.transform_fn(entity, final=True)
                            yield sse_message(final_msg)
                        return
                    
                    # Create data source
                    data_source = endpoint.data_source(id)
                    if callable(data_source) and not hasattr(data_source, '__anext__'):
                        data_source = data_source()
                    
                    # Stream with SSEStream wrapper
                    config = endpoint.config or self.default_config
                    stream_wrapper = SSEStream(config)
                    
                    async for message in stream_wrapper.stream(
                        data_source, 
                        lambda data: endpoint.transform_fn(data, entity_id=id) if endpoint.transform_fn else data
                    ):
                        yield message
                        
                finally:
                    # Unregister connection
                    await self.connection_registry.remove_connection(connection.connection_id)
            
            return EventStream(stream())
        
        return handler
    
    def setup_routes(
        self,
        app,  # FastHTML app
        get_entity_fn: Callable,  # Function to get entity state
        is_active_fn: Callable  # Function to check if entity is active
    ):
        """Setup all stream routes on the app."""
        for stream_name, endpoint in self.endpoints.items():
            path = f"{self.base_path}{endpoint.path_suffix}"
            handler = self.create_handler(stream_name, get_entity_fn, is_active_fn)
            
            # Register route
            app.route(path)(handler)
            
            if self.debug:
                print(f"[MultiStreamManager] Registered route: {path}")

# %% ../../nbs/core/multi_stream.ipynb 12
def create_multi_stream_row(
    manager: MultiStreamManager,  # Multi-stream manager
    entity_id: str,  # Entity ID
    streams: List[Dict[str, Any]],  # List of stream configurations
    row_builder: Callable,  # Function to build the row
    active: bool = True  # Whether streams should be active
) -> FT:  # Table row or similar element
    """Create a row element with multiple SSE streams."""
    stream_elements = {}
    
    for stream_config in streams:
        stream_name = stream_config['name']
        cell_id = stream_config.get('cell_id', f"{entity_id}-{stream_name}")
        content = stream_config.get('initial_content', '')
        
        if active and stream_config.get('active', True):
            # Create SSE-enabled element
            element = manager.create_element(
                entity_id=entity_id,
                stream_name=stream_name,
                element_id=cell_id,
                wrapper=stream_config.get('wrapper', Span)
            )
            # Add initial content if provided
            if content:
                element.children = [content] if not isinstance(content, list) else content
            stream_elements[stream_name] = element
        else:
            # Static content for inactive streams
            stream_elements[stream_name] = content
    
    return row_builder(entity_id, stream_elements)
