"""SSE streaming utilities and helpers"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/streaming.ipynb.

# %% auto 0
__all__ = ['StreamConfig', 'SSEStream', 'OOBStreamBuilder']

# %% ../../nbs/core/streaming.ipynb 3
import asyncio
import json
from typing import AsyncGenerator, Callable, Optional, Any, Dict, List, Union
from datetime import datetime
from dataclasses import dataclass
from fasthtml.common import EventStream, sse_message, Div, FT

# %% ../../nbs/core/streaming.ipynb 5
@dataclass
class StreamConfig:
    """Configuration for SSE streaming"""
    heartbeat_interval: float = 30.0
    timeout: Optional[float] = None
    send_initial_message: bool = True
    initial_message: str = "Connected"
    send_close_message: bool = True
    close_message: str = "Connection closed"
    debug: bool = False

# %% ../../nbs/core/streaming.ipynb 8
class SSEStream:
    """Generic SSE stream handler"""
    
    def __init__(
        self,
        config: Optional[StreamConfig] = None  # Stream configuration
    ):
        """Initialize the SSE stream."""
        self.config = config or StreamConfig()
        self._active = False
        self._message_count = 0
    
    async def stream(self,
                    data_source: Union[AsyncGenerator, Callable], # Async generator or callable that produces data
                    transform_fn: Optional[Callable] = None # Optional function to transform data before sending
                    ) -> AsyncGenerator[str, None]: # SSE formatted strings
        """Stream data from a source through SSE."""
        self._active = True
        
        try:
            # Send initial message
            if self.config.send_initial_message:
                yield f": {self.config.initial_message}\n\n"
            
            # Create async generator from callable if needed
            if callable(data_source) and not hasattr(data_source, '__anext__'):
                data_source = data_source()
            
            # Main streaming loop
            while self._active:
                try:
                    # Get data with heartbeat timeout
                    data = await asyncio.wait_for(
                        data_source.__anext__(),
                        timeout=self.config.heartbeat_interval
                    )
                    
                    # Transform data if function provided
                    if transform_fn:
                        data = await transform_fn(data) if asyncio.iscoroutinefunction(transform_fn) else transform_fn(data)
                    
                    # Send data
                    if data is not None:
                        self._message_count += 1
                        yield self._format_message(data)
                    
                except asyncio.TimeoutError:
                    # Send heartbeat
                    yield f": heartbeat {datetime.now().isoformat()}\n\n"
                    
                except StopAsyncIteration:
                    # Data source exhausted
                    break
                    
        except Exception as e:
            if self.config.debug:
                yield f": error {str(e)}\n\n"
            raise
            
        finally:
            self._active = False
            if self.config.send_close_message:
                yield f": {self.config.close_message}\n\n"
    
    def _format_message(
        self,
        data: Any  # Data to format
    ) -> str:  # SSE formatted string
        """Format data as SSE message."""
        if isinstance(data, str):
            return f"data: {data}\n\n"
        elif isinstance(data, dict):
            return f"data: {json.dumps(data)}\n\n"
        elif hasattr(data, '__html__'):
            # FastHTML element
            return sse_message(data)
        else:
            # Try to convert to JSON
            try:
                return f"data: {json.dumps(data)}\n\n"
            except (TypeError, ValueError):
                return f"data: {str(data)}\n\n"
    
    def stop(self):
        """Stop the stream."""
        self._active = False

# %% ../../nbs/core/streaming.ipynb 14
class OOBStreamBuilder:
    """Build SSE messages with OOB (Out-of-Band) swaps"""
    
    def __init__(self):
        """Initialize the OOB stream builder."""
        self.elements: List[Any] = []
    
    def add_element(self,
                   element: Any,  # The element to add
                   target_id: Optional[str] = None,  # Target element ID for OOB swap
                   swap_mode: str = "innerHTML",  # Swap mode (innerHTML, outerHTML, beforeend, afterbegin, etc.)
                   wrap: bool = True  # If True and target_id is provided, wrap content in a Div with OOB attributes. If False, add OOB attributes directly to the element
                   ) -> 'OOBStreamBuilder':  # Self for chaining
        """Add an element with OOB swap configuration."""
        if target_id:
            if wrap and swap_mode == "innerHTML":
                # For innerHTML swaps, wrap the content in a container with the target ID
                # This is the most common case for replacing content
                wrapper = Div(element, id=target_id, hx_swap_oob="innerHTML")
                self.elements.append(wrapper)
            elif wrap and swap_mode != "outerHTML":
                # For other swap modes (beforeend, afterbegin, etc.), also wrap
                wrapper = Div(element, id=target_id, hx_swap_oob=swap_mode)
                self.elements.append(wrapper)
            else:
                # For outerHTML swaps or when wrap=False, add attributes directly to element
                if hasattr(element, 'attrs'):
                    # Only set ID if element doesn't already have one or if it matches target_id
                    if not element.attrs.get('id') or element.attrs.get('id') == target_id:
                        element.attrs['id'] = target_id
                    element.attrs['hx-swap-oob'] = swap_mode if swap_mode != "innerHTML" else "true"
                elif isinstance(element, dict):
                    if not element.get('id') or element.get('id') == target_id:
                        element['id'] = target_id
                    element['hx-swap-oob'] = swap_mode if swap_mode != "innerHTML" else "true"
                self.elements.append(element)
        else:
            # No target_id, just add the element as-is
            self.elements.append(element)
        
        return self
    
    def add_elements(
        self,
        elements: List[tuple]  # List of tuples: (element, target_id, swap_mode, wrap) or (element, target_id, swap_mode) or (element, target_id) or (element,)
    ) -> 'OOBStreamBuilder':  # Self for chaining
        """Add multiple elements with OOB configurations."""
        for item in elements:
            if len(item) == 4:
                element, target_id, swap_mode, wrap = item
            elif len(item) == 3:
                element, target_id, swap_mode = item
                wrap = True  # Default to wrapping
            elif len(item) == 2:
                element, target_id = item
                swap_mode = "innerHTML"
                wrap = True
            else:
                element = item[0] if isinstance(item, tuple) else item
                target_id = None
                swap_mode = "innerHTML"
                wrap = True
            
            self.add_element(element, target_id, swap_mode, wrap)
        
        return self
    
    def build(
        self
    ) -> FT:  # Div with all elements
        """Build the Div element with all elements."""
        if not self.elements:
            return ""
        
        if len(self.elements) == 1:
            return sse_message(self.elements[0])
        
        # Wrap multiple elements in a container
        return Div(*self.elements)
    
    def clear(
        self
    ) -> 'OOBStreamBuilder':  # Self for chaining
        """Clear all elements."""
        self.elements = []
        return self
