Index: mcp_email_server/config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nimport datetime\nimport os\nfrom pathlib import Path\n\nimport tomli_w\nfrom pydantic import BaseModel, Field, model_validator\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n    TomlConfigSettingsSource,\n)\n\nfrom mcp_email_server.log import logger\n\nDEFAILT_CONFIG_PATH = \"~/.config/zerolib/mcp_email_server/config.toml\"\n\nCONFIG_PATH = Path(os.getenv(\"MCP_EMAIL_SERVER_CONFIG_PATH\", DEFAILT_CONFIG_PATH)).expanduser().resolve()\n\n\nclass EmailServer(BaseModel):\n    user_name: str\n    password: str\n    host: str\n    port: int\n    use_ssl: bool = True  # Usually port 465\n    start_ssl: bool = False  # Usually port 587\n\n    def masked(self) -> EmailServer:\n        return self.model_copy(update={\"password\": \"********\"})\n\n\nclass AccountAttributes(BaseModel):\n    account_name: str\n    description: str = \"\"\n    created_at: datetime.datetime = Field(default_factory=datetime.datetime.now)\n    updated_at: datetime.datetime = Field(default_factory=datetime.datetime.now)\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def update_updated_at(cls, obj: AccountAttributes) -> AccountAttributes:\n        \"\"\"Update updated_at field.\"\"\"\n        # must disable validation to avoid infinite loop\n        obj.model_config[\"validate_assignment\"] = False\n\n        # update updated_at field\n        obj.updated_at = datetime.datetime.now()\n\n        # enable validation again\n        obj.model_config[\"validate_assignment\"] = True\n        return obj\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AccountAttributes):\n            return NotImplemented\n        return self.model_dump(exclude={\"created_at\", \"updated_at\"}) == other.model_dump(\n            exclude={\"created_at\", \"updated_at\"}\n        )\n\n    def masked(self) -> AccountAttributes:\n        return self.model_copy()\n\n\nclass EmailSettings(AccountAttributes):\n    full_name: str\n    email_address: str\n    incoming: EmailServer\n    outgoing: EmailServer\n\n    @classmethod\n    def init(\n        cls,\n        *,\n        account_name: str,\n        full_name: str,\n        email_address: str,\n        user_name: str,\n        password: str,\n        imap_host: str,\n        smtp_host: str,\n        imap_user_name: str | None = None,\n        imap_password: str | None = None,\n        imap_port: int = 993,\n        imap_ssl: bool = True,\n        smtp_port: int = 465,\n        smtp_ssl: bool = True,\n        smtp_start_ssl: bool = False,\n        smtp_user_name: str | None = None,\n        smtp_password: str | None = None,\n    ) -> EmailSettings:\n        return cls(\n            account_name=account_name,\n            full_name=full_name,\n            email_address=email_address,\n            incoming=EmailServer(\n                user_name=imap_user_name or user_name,\n                password=imap_password or password,\n                host=imap_host,\n                port=imap_port,\n                use_ssl=imap_ssl,\n            ),\n            outgoing=EmailServer(\n                user_name=smtp_user_name or user_name,\n                password=smtp_password or password,\n                host=smtp_host,\n                port=smtp_port,\n                use_ssl=smtp_ssl,\n                start_ssl=smtp_start_ssl,\n            ),\n        )\n\n    def masked(self) -> EmailSettings:\n        return self.model_copy(\n            update={\n                \"incoming\": self.incoming.masked(),\n                \"outgoing\": self.outgoing.masked(),\n            }\n        )\n\n\nclass ProviderSettings(AccountAttributes):\n    provider_name: str\n    api_key: str\n\n    def masked(self) -> AccountAttributes:\n        return self.model_copy(update={\"api_key\": \"********\"})\n\n\nclass Settings(BaseSettings):\n    emails: list[EmailSettings] = []\n    providers: list[ProviderSettings] = []\n    db_location: str = CONFIG_PATH.with_name(\"db.sqlite3\").as_posix()\n\n    model_config = SettingsConfigDict(toml_file=CONFIG_PATH, validate_assignment=True, revalidate_instances=\"always\")\n\n    def add_email(self, email: EmailSettings) -> None:\n        \"\"\"Use re-assigned for validation to work.\"\"\"\n        self.emails = [email, *self.emails]\n\n    def add_provider(self, provider: ProviderSettings) -> None:\n        \"\"\"Use re-assigned for validation to work.\"\"\"\n        self.providers = [provider, *self.providers]\n\n    def delete_email(self, account_name: str) -> None:\n        \"\"\"Use re-assigned for validation to work.\"\"\"\n        self.emails = [email for email in self.emails if email.account_name != account_name]\n\n    def delete_provider(self, account_name: str) -> None:\n        \"\"\"Use re-assigned for validation to work.\"\"\"\n        self.providers = [provider for provider in self.providers if provider.account_name != account_name]\n\n    def get_account(self, account_name: str, masked: bool = False) -> EmailSettings | ProviderSettings | None:\n        for email in self.emails:\n            if email.account_name == account_name:\n                return email if not masked else email.masked()\n        for provider in self.providers:\n            if provider.account_name == account_name:\n                return provider if not masked else provider.masked()\n        return None\n\n    def get_accounts(self, masked: bool = False) -> list[EmailSettings | ProviderSettings]:\n        accounts = self.emails + self.providers\n        if masked:\n            return [account.masked() for account in accounts]\n        return accounts\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def check_unique_account_names(cls, obj: Settings) -> Settings:\n        account_names = set()\n        for email in obj.emails:\n            if email.account_name in account_names:\n                raise ValueError(f\"Duplicate account name {email.account_name}\")\n            account_names.add(email.account_name)\n        for provider in obj.providers:\n            if provider.account_name in account_names:\n                raise ValueError(f\"Duplicate account name {provider.account_name}\")\n            account_names.add(provider.account_name)\n\n        return obj\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (TomlConfigSettingsSource(settings_cls),)\n\n    def _to_toml(self) -> str:\n        data = self.model_dump()\n        return tomli_w.dumps(data)\n\n    def store(self) -> None:\n        toml_file = self.model_config[\"toml_file\"]\n        toml_file.parent.mkdir(parents=True, exist_ok=True)\n        toml_file.write_text(self._to_toml())\n        logger.info(f\"Settings stored in {toml_file}\")\n\n\n_settings = None\n\n\ndef get_settings(reload: bool = False) -> Settings:\n    global _settings\n    if not _settings or reload:\n        logger.info(f\"Loading settings from {CONFIG_PATH}\")\n        _settings = Settings()\n    return _settings\n\n\ndef store_settings(settings: Settings | None = None) -> None:\n    if not settings:\n        settings = get_settings()\n    settings.store()\n    return\n\n\ndef delete_settings() -> None:\n    if not CONFIG_PATH.exists():\n        logger.info(f\"Settings file {CONFIG_PATH} does not exist\")\n        return\n    CONFIG_PATH.unlink()\n    logger.info(f\"Deleted settings file {CONFIG_PATH}\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mcp_email_server/config.py b/mcp_email_server/config.py
--- a/mcp_email_server/config.py	(revision cba982c8fd5955948174e746afe25f58f00066d5)
+++ b/mcp_email_server/config.py	(date 1756091800570)
@@ -35,8 +35,8 @@
 class AccountAttributes(BaseModel):
     account_name: str
     description: str = ""
-    created_at: datetime.datetime = Field(default_factory=datetime.datetime.now)
-    updated_at: datetime.datetime = Field(default_factory=datetime.datetime.now)
+    created_at: datetime.datetime = Field(default_factory=datetime.datetime.now, json_schema_extra={"format": "date-time"})
+    updated_at: datetime.datetime = Field(default_factory=datetime.datetime.now, json_schema_extra={"format": "date-time"})
 
     @model_validator(mode="after")
     @classmethod
