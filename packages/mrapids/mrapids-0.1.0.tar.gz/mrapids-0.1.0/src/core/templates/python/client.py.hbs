"""{{info.title}} API Client
Generated by MicroRapid
"""
import httpx
from typing import Optional, Dict, Any, Union
from .types import ApiConfig, ApiError
from .models import *


class ApiClient:
    """Main API client for {{info.title}}"""
    
    def __init__(self, config: ApiConfig = None):
        if config is None:
            config = ApiConfig()
        self.config = config
        self.base_url = config.base_url or "{{baseUrl}}"
        self._client = httpx.Client(
            base_url=self.base_url,
            timeout=config.timeout,
            {{#if includeAuth}}
            headers=self._get_auth_headers()
            {{/if}}
        )
    
    {{#if includeAuth}}
    def _get_auth_headers(self) -> Dict[str, str]:
        """Get authentication headers"""
        headers = {}
        if hasattr(self.config, 'bearer_token') and self.config.bearer_token:
            headers["Authorization"] = f"Bearer {self.config.bearer_token}"
        if hasattr(self.config, 'api_key') and self.config.api_key:
            # Assuming API key goes in header
            headers["X-API-Key"] = self.config.api_key
        return headers
    {{/if}}
    
    def _request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Any:
        """Make an HTTP request"""
        try:
            response = self._client.request(
                method=method,
                url=path,
                params=params,
                json=json,
                headers=headers,
            )
            response.raise_for_status()
            return response.json() if response.content else None
        except httpx.HTTPStatusError as e:
            raise ApiError(f"HTTP {e.response.status_code}: {e.response.text}", e.response.status_code)
        except Exception as e:
            raise ApiError(str(e), 0)
    
    {{#each operations}}
    def {{snakeCase operation_id}}(
        self,
        {{#each parameters}}
        {{snakeCase name}}: {{#if required}}{{else}}Optional[{{/if}}Any{{#if required}}{{else}}] = None{{/if}},
        {{/each}}
        {{#if requestBody}}
        body: {{#if requestBody.required}}{{else}}Optional[{{/if}}Dict[str, Any]{{#if requestBody.required}}{{else}}] = None{{/if}},
        {{/if}}
    ) -> Any:
        """
        {{#if summary}}{{summary}}{{/if}}
        {{#if description}}
        
        {{description}}
        {{/if}}
        """
        {{#if parameters}}
        params = {}
        {{#each parameters}}
        # Assuming query parameters (adjust if needed)
        if {{snakeCase name}} is not None:
            params["{{name}}"] = {{snakeCase name}}
        {{/each}}
        {{/if}}
        
        path = "{{path}}"
        {{#each parameters}}
        # Replace path parameters
        path = path.replace("{{{name}}}", str({{snakeCase name}}))
        {{/each}}
        
        return self._request(
            method="{{method}}",
            path=path,
            {{#if parameters}}params=params,{{/if}}
            {{#if requestBody}}json=body,{{/if}}
        )
    
    {{/each}}
    
    def close(self):
        """Close the HTTP client"""
        self._client.close()
    
    def __enter__(self):
        return self
    
    def __exit__(self, *args):
        self.close()