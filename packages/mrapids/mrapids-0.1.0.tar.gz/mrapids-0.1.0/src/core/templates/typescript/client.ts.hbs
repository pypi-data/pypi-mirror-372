/**
 * {{info.title}} API Client
 * Version: {{info.version}}
 * {{#if info.description}}
 * {{info.description}}
 * {{/if}}
 * 
 * Generated by MicroRapid - https://github.com/deepwissen/api-runtime
 */

import { ApiConfig, ApiError, PaginationOptions } from './types';
import * as Models from './models';

export class ApiClient {
    private config: ApiConfig;
    private baseUrl: string;

    constructor(config: ApiConfig) {
        this.config = config;
        this.baseUrl = config.baseUrl || '{{baseUrl}}';
    }

    {{#if includeAuth}}
    /**
     * Update authentication configuration
     */
    setAuth(auth: ApiConfig['auth']) {
        this.config.auth = auth;
    }
    {{/if}}

    /**
     * Make HTTP request with error handling
     */
    private async request<T>(
        method: string,
        path: string,
        options: {
            params?: Record<string, any>;
            body?: any;
            headers?: Record<string, string>;
        } = {}
    ): Promise<T> {
        const url = new URL(path, this.baseUrl);
        
        // Add query parameters
        if (options.params) {
            Object.entries(options.params).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                    url.searchParams.append(key, String(value));
                }
            });
        }

        const headers: Record<string, string> = {
            'Content-Type': 'application/json',
            ...options.headers,
        };

        {{#if includeAuth}}
        // Add authentication headers
        if (this.config.auth) {
            if (this.config.auth.bearer) {
                headers.Authorization = `Bearer ${this.config.auth.bearer}`;
            } else if (this.config.auth.apiKey) {
                const { name, value, in: location } = this.config.auth.apiKey;
                if (location === 'header') {
                    headers[name] = value;
                } else if (location === 'query') {
                    url.searchParams.append(name, value);
                }
            }
        }
        {{/if}}

        const requestInit: RequestInit = {
            method,
            headers,
        };

        if (options.body) {
            requestInit.body = JSON.stringify(options.body);
        }

        {{#if includeResilience}}
        // Retry logic
        let attempt = 0;
        const maxRetries = this.config.maxRetries ?? 3;
        const retryDelay = this.config.retryDelay ?? 1000;

        while (attempt <= maxRetries) {
            try {
        {{/if}}
                const response = await fetch(url.toString(), requestInit);

                if (!response.ok) {
                    throw new ApiError(
                        `HTTP ${response.status}: ${response.statusText}`,
                        response.status,
                        await response.text()
                    );
                }

                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    return await response.json();
                }

                return {} as T;
        {{#if includeResilience}}
            } catch (error) {
                attempt++;
                if (attempt > maxRetries || !(error instanceof ApiError) || error.status < 500) {
                    throw error;
                }
                
                // Wait before retry
                await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
            }
        }
        
        throw new Error('Max retries exceeded');
        {{/if}}
    }

    {{#each operations}}
    /**
     * {{#if summary}}{{summary}}{{else}}{{operation_id}}{{/if}}
     * {{method}} {{path}}
     * {{#if description}}
     * 
     * {{description}}
     * {{/if}}
     */
    async {{operation_id}}(
        {{#if parameters}}
        params: {
            {{#each parameters}}
            {{#if required}}{{name}}{{else}}{{name}}?{{/if}}: {{#if (eq type_info.base_type "string")}}string{{else if (eq type_info.base_type "integer")}}number{{else if (eq type_info.base_type "boolean")}}boolean{{else}}any{{/if}};
            {{/each}}
        }{{#if request_body}},{{/if}}
        {{/if}}
        {{#if request_body}}
        body{{#unless request_body.required}}?{{/unless}}: {{#if (eq request_body.type_info.base_type "object")}}Record<string, any>{{else}}any{{/if}}{{#if options}},{{/if}}
        {{/if}}
        {{#if (or includePagination includeResilience)}}
        options?: {
            {{#if includePagination}}
            pagination?: PaginationOptions;
            {{/if}}
            {{#if includeResilience}}
            timeout?: number;
            {{/if}}
        }
        {{/if}}
    ): Promise<{{#if responses.[0].type_info}}{{#if (eq responses.[0].type_info.base_type "array")}}Array<any>{{else if (eq responses.[0].type_info.base_type "object")}}Record<string, any>{{else}}any{{/if}}{{else}}void{{/if}}> {
        {{#if parameters}}
        const queryParams: Record<string, any> = {};
        const pathParams: Record<string, any> = {};
        
        {{#each parameters}}
        {{#if (eq in_location "query")}}
        if (params.{{name}} !== undefined) queryParams.{{name}} = params.{{name}};
        {{else if (eq in_location "path")}}
        pathParams.{{name}} = params.{{name}};
        {{/if}}
        {{/each}}
        
        // Replace path parameters
        let path = '{{path}}';
        {{#each parameters}}
        {{#if (eq in_location "path")}}
        path = path.replace('{{{name}}}', String(pathParams.{{name}}));
        {{/if}}
        {{/each}}
        {{else}}
        const path = '{{path}}';
        const queryParams = {};
        {{/if}}

        return this.request('{{method}}', path, {
            {{#if parameters}}params: queryParams,{{/if}}
            {{#if request_body}}body,{{/if}}
        });
    }

    {{/each}}
}

export default ApiClient;