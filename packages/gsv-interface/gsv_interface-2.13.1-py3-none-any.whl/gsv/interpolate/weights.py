import os
from pathlib import Path
import logging
import typing as T

import numpy as np
import xarray as xr
import smmregrid

from gsv.logger import get_logger
from gsv.grids import Grid
from gsv.exceptions import InvalidInterpolationMethodError


def flatten(da: xr.DataArray) -> xr.DataArray:
    """
    Flatten a 3D or 4D data array into a flat
    array by selecting only its first timestep,
    and first vertical level (for 4D variables).

    The resulting array will only have the
    horizonlat dimensions (which may depend on
    the grid).

    Arguments:
    ----------
    da : xr.DataArray
        3D or 4D dataArray

    Returns:
    --------
    xr.DataArray
        Flat data Array
    """
    if "time" in da.dims:
        da = da.isel(time=0)
    if "level" in da.dims:
        da = da.isel(level=0)

    return da


def get_weights_name(
    da: xr.DataArray, input_grid: Grid,
    output_grid: Grid, method: str
    ) -> str:
    """
    Get unique identifier of weights dataset.

    The weights dataset depends on the interpolation method,
    input grid, output grid and on the land-sea mask.

    The unique identifies follows a regex pattern:
    'weights_<method>_<input_grid_id>_<output_grid>_<mask_id>'.

    <method> is just the interpolation method: 'nn' or 'con'.
    <input_grid> is the CDO identifier for the source grid.
    <output_grid> is the CDO identifier for the target grid.
    <mask_id> will be different for atmospheric and ocean variables.

    For atmospheric variables, no mask is needed. A common mask
    id 'atmos' is defined for all atmospheric variables.

    For oceanic variables, the mask will depend on the
    depth of the field. A mask id 'ocean_{depth}' is assigned
    to each of the ocean levels.

    Arguments:
    ----------
    da : xr.DataArray
        DataArray in the source grid, with correct variable name,
        mask and vertical level.
    input_grid : gsv.grids.Grid
        Grid object representing the source data grid.
    output_grid : gsv.grids.Grid
        Grid object representing the target data grid.
    method : str
        Interpolation method used to calculate weights: 'nn' or 'con'.

    Returns:
    --------
    str
        Unique identifier of weights dataset.
    """
    vartype = "ocean" if np.isnan(da.values).any() else "atmos"

    level = da.level.values[0] if "level" in da.dims else "sfc"
    mask_id = f"ocean_{level}" if vartype == "ocean" else "atmos"

    return f"weights_{method}_{input_grid.grid_id}_" \
           f"{output_grid.grid_id}_{mask_id}"


def get_weights_filename(
    da: xr.DataArray,
    input_grid: Grid,
    output_grid: Grid,
    method: str,
    ) -> str:
    """
    Get the netCDF filename of a given weights dataset.

    The filename is just the output from .get_weights_name()
    with the path to weights files prepended and the '.nc'
    file extension for netCDF appended.

    Arguments:
    ----------
    da : xr.DataArray
        DataArray in the source grid, with correct variable name,
        mask and vertical level.
    input_grid : gsv.grids.Grid
        Grid object representing the source data grid.
    output_grid : gsv.grids.Grid
        Grid object representing the target data grid.
    method : str
        Interpolation method used to calculate weights: 'nn' or 'con'.

    Returns:
    --------
    str
        netCDF file name of weights dataset.
    """
    try:
        weights_path = os.environ["GSV_WEIGHTS_PATH"]
    except KeyError:
        return None
    else:
        weights_name = get_weights_name(da, input_grid, output_grid, method)
        return Path(f"{weights_path}/{weights_name}.nc")


def compute_weights(
    src_da: xr.DataArray, input_grid: Grid, output_grid: Grid, method: str) -> xr.Dataset:
    """
    TODO: update docstrings.

    Compute interpolation weights dataset.

    Interpolation weights dataset in created using ``smmregrid``
    which uses CDO to compute the weights.

    A source DataArray must be provided, as long as the output_grid
    and interpolation method. The input grid is extracted
    from the source DataArray.

    For masked variables, the source DataArray must be
    correctly masked.

    Arguments:
    ----------
    src_da : xr.DataArray
        DataArray in the source grid, with correct mask.
    output_grid : gsv.grids.Grid
        Grid object representing the target grid.
    method : str
        Interpolation method used to calculate weights: 'nn' or 'con'.

    Returns:
    --------
    xr.Dataset
        Interpolation weights dataset generated by CDO
    """
    # TODO: Document this!!!
    trg_name = output_grid.grid_id
    src_ds = input_grid.create_dummy_variable()
    src_ds["dummy"] = src_da
    src_ds = flatten(src_ds)
    cdo_generate = smmregrid.CdoGenerate(
        source_grid=src_ds,
        target_grid=trg_name,
    )
    return cdo_generate.weights(method=method)


def get_weights(
    da: xr.DataArray,
    input_grid: Grid,
    output_grid: Grid,
    method: str,
    logger: T.Optional[logging.Logger]=None
    ) -> xr.Dataset:
    """
    Get interpolation weights dataset.

    The interpolation weights unique identifier
    is obtained using the information on the source
    DataArray, input_grid, output_grid and interpolation method.

    If a dataset netCDF file exists with that name, the interpolation
    weights are read from file.

    If dataset netCDF file does not exist, it is then calculated.

    Arguments:
    ----------
    da : xr.DataArray
        DataArray in the source grid, with correct variable name,
        mask and vertical level.
    input_grid : gsv.grids.Grid
        Grid object representing the source data grid.
    output_grid : gsv.grids.Grid
        Grid object representing the target data grid.
    method : str
        Interpolation method used to calculate weights: 'nn' or 'con'.
    logger : (optional) logging.Logger
        Logger object to handle log messages. If none provided, basic
        Python Print will be used.

    Returns:
    --------
    xr.Dataset
        Interpolation weights dataset
    """
    # Create dummy logger if none provided
    if logger is None:
        logger = get_logger(logger_name=__name__, logging_level="INFO")

    if method not in ['nn', 'con']:
        raise InvalidInterpolationMethodError(method)

    weights_file = get_weights_filename(
        da, input_grid, output_grid, method
    )

    if weights_file is not None and weights_file.is_file():
        logger.debug(f"Loading weights file: {weights_file}")
        return xr.open_dataset(weights_file)

    elif weights_file is not None and not weights_file.is_file():
        logger.debug(
            f"Missing weights file {weights_file}. Computing weights."
            )
        return compute_weights(
            da, input_grid, output_grid, method
        )

    elif weights_file is None:
        logger.debug(
           "Environment variable 'GSV_WEIGHTS_PATH' is not defined. "
           "Cannot use precomputed weights. Computing weights."
           )
        return compute_weights(
            da, input_grid, output_grid, method
        )
