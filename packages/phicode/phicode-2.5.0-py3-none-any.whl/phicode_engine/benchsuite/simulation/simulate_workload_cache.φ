# (φ) src/phicode_engine/benchsuite/simulation/simulate_workload_cache.φ
# Copyright 2025 Baleine Jay
# Licensed under the PhiCode Non-Commercial License (https://banes-lab.com/licensing)
# Commercial use requires a paid license. See link for details.
⇒ time
← phicode_engine.core.cache.phicode_cache ⇒ _cache
← phicode_engine.core.cache.phicode_bytecode ⇒ BytecodeManager, _flush_batch_writes
← phicode_engine.config.config ⇒ PYTHON_TO_PHICODE, MAIN_FILE_TYPE

π("💾 Cache Load Test - Real Engine")

symbols = list(PYTHON_TO_PHICODE.values())

# Realistic φ code patterns (your style - small, focused)
patterns = [
    "def process_data(items):\n    return [x*2 for x in items]",
    "if condition:\n    print('executed')\nelse:\n    print('skipped')",
    "for i in range(10):\n    if i % 2:\n        print(i)",
    "def validate(data):\n    return data is not None and len(data) > 0"
]

start_time = time.perf_counter()
cache_hits = 0
cache_misses = 0

# Simulate realistic project load - 100 small files
∀ file_id ∈ range(100):
    ∀ pattern_id, pattern ∈ enumerate(patterns):
        cache_key = f"file_{file_id}_pattern_{pattern_id}"

        # Check ¿ already cached
        initial_size = len(_cache.python_cache)

        # Use real cache
        result = _cache.get_python_source(cache_key, pattern)

        # Use real bytecode manager
        BytecodeManager.compile_and_cache(result, f"{cache_key}{MAIN_FILE_TYPE}")

        # Track hit/miss
        ¿ len(_cache.python_cache) > initial_size:
            cache_misses += 1
        ⋄:
            cache_hits += 1

# Flush real batch writes
_flush_batch_writes()

total_time = time.perf_counter() - start_time
total_ops = cache_hits + cache_misses
hit_rate = cache_hits / total_ops ¿ total_ops > 0 ⋄ 0

π(f"  Operations: {total_ops}")
π(f"  Cache hits: {cache_hits}")
π(f"  Hit rate: {hit_rate:.2f}")
π(f"  Total time: {total_time*1000:.1f}ms")
π(f"  Avg per op: {total_time*1000/total_ops:.1f}ms")