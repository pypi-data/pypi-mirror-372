# (Ï†) src/phicode_engine/benchsuite/simulation/simulate_concurrency.Ï†
# Copyright 2025 Baleine Jay
# Licensed under the PhiCode Non-Commercial License (https://banes-lab.com/licensing)
# Commercial use requires a paid license. See link for details.
â‡’ time
â‡’ threading
â† phicode_engine.core.transpilation.phicode_to_python â‡’ transpile_symbols
â† phicode_engine.core.cache.phicode_cache â‡’ _cache
â† phicode_engine.core.cache.phicode_bytecode â‡’ BytecodeManager, _flush_batch_writes
â† phicode_engine.config.config â‡’ PYTHON_TO_PHICODE, MAIN_FILE_TYPE


Ï€("ğŸ”„ Concurrent Engine Test - Real Components")

symbols = list(PYTHON_TO_PHICODE.values())

test_code = f"""
def worker_function(worker_id):
    results = []
    for i in range(10):
        if i % 2 == 0:
            value = f"worker_{{worker_id}}_item_{{i}}"
            results.append(value)
    return results
"""

results = []
errors = []

Æ’ worker_thread(worker_id):
    âˆ´:
        start = time.perf_counter()

        # Each worker hits multiple engine components
        âˆ€ operation âˆˆ range(50):
            cache_key = f"worker_{worker_id}_op_{operation}"

            # Hit transpiler
            transpiled = transpile_symbols(test_code)

            # Hit cache
            _cache.get_python_source(cache_key, test_code)

            # Hit bytecode manager
            BytecodeManager.compile_and_cache(transpiled, f"{cache_key}{MAIN_FILE_TYPE}")

        end = time.perf_counter()
        results.append((worker_id, end - start))

    â›’ Exception â†¦ e:
        errors.append((worker_id, str(e)))

# Test âˆ¥ realistic concurrency
thread_count = 8
threads = []

start_time = time.perf_counter()

# Start all workers
âˆ€ i âˆˆ range(thread_count):
    t = threading.Thread(target=worker_thread, args=(i,))
    threads.append(t)
    t.start()

# Wait âˆ€ completion
âˆ€ t âˆˆ threads:
    t.join()

total_time = time.perf_counter() - start_time

# Flush any pending writes
_flush_batch_writes()

# Results
successful_workers = len(results)
failed_workers = len(errors)

Â¿ results:
    avg_worker_time = sum(time âˆ€ _, time âˆˆ results) / len(results)
    fastest_worker = min(time âˆ€ _, time âˆˆ results)
    slowest_worker = max(time âˆ€ _, time âˆˆ results)
â‹„:
    avg_worker_time = fastest_worker = slowest_worker = 0

Ï€(f"  Workers: {thread_count}")
Ï€(f"  Successful: {successful_workers}")
Ï€(f"  Failed: {failed_workers}")
Ï€(f"  Total time: {total_time*1000:.1f}ms")
Ï€(f"  Avg worker time: {avg_worker_time*1000:.1f}ms")
Ï€(f"  Fastest worker: {fastest_worker*1000:.1f}ms")
Ï€(f"  Slowest worker: {slowest_worker*1000:.1f}ms")

Â¿ errors:
    Ï€(f"  Errors: {[f'Worker {w}: {e}' for w, e in errors[:3]]}")  # Show first 3