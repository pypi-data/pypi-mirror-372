# Copyright 2025 Baleine Jay
# Licensed under the PhiCode Non-Commercial License (https://banes-lab.com/licensing)
# Commercial use requires a paid license. See link for details.
⇒ time
⇒ statistics
⇒ gc

← phicode_engine.core.transpilation.phicode_to_python ⇒ SymbolTranspiler
← phicode_engine.benchsuite ⇒ report

transpiler = SymbolTranspiler()

test_patterns = {
            "simple": "∀ x ∈ data: π(x)",
            "medium": """
∀ item ∈ items:
    ¿ item.is_valid() ∧ item.status == "active":
        π(f"Processing {item}")
        result = process_item(item)
        ¿ result ≡ ¬ Ø:
            π(f"Success: {result}")
        ⋄:
            π("Failed to process")
            """,
            "complex": """
# Complex phi code with many symbols
ƒ process_data(data):
    ∴:
        ∀ item ∈ data:
            ¿ item ≡ Ø ∨ ¬ item.is_valid():
                ⇉

            ¿ hasattr(item, 'value') ∧ item.value > 0:
                result = calculate_result(item)
                ¿ result ≡ ¬ Ø:
                    π(f"Item {item.id}: {result}")
                    yield_value = result * 2
                    ⟰ yield_value
                ⋄:
                    π("Calculation failed")

        ⟲ ✓
    ⛒ Exception ↦ e:
        π(f"Error: {e}")
        ↑ RuntimeError("Processing failed") ← e
    ⇗:
        π("Cleanup completed")

True_val = ✓
False_val = ⊥
None_val = Ø
            """,
            "heavy_symbols": "∀ ∈ ∧ ∨ ¬ ≡ ≢ ⇉ ⇲ ∴ ⛒ ⇗ ↑ ⟲ ⟰ π" * 50,
            "mixed_content": '''
"""
This == a string with ∀ symbols that should NOT be transpiled
"""
ƒ main():
    # This comment has ∀ symbols too
    data = "∀ x ∈ test"  # String literals protected
    for i in ⟪(10):  # This should be transpiled
        print(f"Value: {i}")
        ¿ i == 5:
            break  # ⇲
        ''',
}

ƒ run_timing_test(content: str, iterations: int = 5) -> dict:
    times = []
    transpiler.transpile(content)

    ∀ i ∈ ⟪(iterations):
        gc.collect()
        start_time = time.perf_counter()
        result = transpiler.transpile(content)
        end_time = time.perf_counter()
        times.append(end_time - start_time)

    chars_per_sec = [ℓ(content) / t ∀ t ∈ times]
    ⟲ {
        "content_size": ℓ(content),
        "avg_time_ms": statistics.mean(times) * 1000,
        "avg_chars_per_sec": statistics.mean(chars_per_sec),
    }

∀ name, pattern ∈ test_patterns.items():
    π(f"\nPattern: {name}")
    π(f"Size: {len(pattern):,} chars")

    result = run_timing_test(pattern, iterations=10)

    π(f"Average Time: {result['avg_time_ms']:.3f}ms")
    π(f"Average Speed: {result['avg_chars_per_sec']:,.0f} chars/sec")

    report(f"pattern_{name}_speed", f"{result['avg_chars_per_sec']:,.0f} chars/sec")
    report(f"pattern_{name}_time", f"{result['avg_time_ms']:.3f}ms")
    report(f"pattern_{name}_size", f"{len(pattern)} chars")

    ¿ result['avg_chars_per_sec'] >= 1_200_000:
        π("✅ Rust acceleration confirmed")
        report(f"pattern_{name}_status", "RUST_CONFIRMED")
    ⤷ result['avg_chars_per_sec'] >= 100_000:
        π("⚠️ Possible acceleration, below target")
        report(f"pattern_{name}_status", "POSSIBLE_ACCELERATION")
    ⋄:
        π("❌ Python fallback detected")
        report(f"pattern_{name}_status", "PYTHON_FALLBACK")