---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/circular_deps_with_stdlib_name_conflict/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
pkg = _cribo.types.SimpleNamespace(__name__='pkg')
class RichRenderable(_cribo.abc.ABC):
    """Abstract base class for renderables."""

    @_cribo.abc.abstractmethod
    def render(self, console):
        """Render this object to the console."""
        pass

    @classmethod
    def __subclasshook__(cls, other):
        """Check if a class implements the render protocol."""
        return hasattr(other, "render")
class ConsoleBase:
    """Base console class for type checking."""
    pass
class Console(ConsoleBase):
    """Main console class with complex dependencies."""

    def __init__(self, force_terminal: _cribo.typing.Optional[bool]=None):
        self.force_terminal = force_terminal
        self._style = Style()
        self._color = Color()

    def print(self, *objects: _cribo.typing.Any, **kwargs) -> None:
        """Print objects to console."""
        for obj in objects:
            if isinstance(obj, RichRenderable):
                output = obj.render(self)
            else:
                output = str(obj)
            print(output, **kwargs)

    def is_renderable(self, obj: _cribo.typing.Any) -> bool:
        """Check if object is renderable."""
        return isinstance(obj, RichRenderable)
class Color:
    """Color representation for console output."""

    def __init__(self, r: int=0, g: int=0, b: int=0):
        self.r = r
        self.g = g
        self.b = b

    def to_rgb(self) -> _cribo.typing.Tuple[int, int, int]:
        """Convert to RGB tuple."""
        return self.r, self.g, self.b

    def to_hex(self) -> str:
        """Convert to hex string."""
        return f"#{self.r:02x}{self.g:02x}{self.b:02x}"
class Style:
    """Style configuration for console output."""

    def __init__(self, color: _cribo.typing.Optional[str]=None):
        self.color = color or "default"
        self._color_obj = Color()

    def apply(self, text: str) -> str:
        """Apply style to text."""
        return f"[{self.color}]{text}[/{self.color}]"

    def get_color(self) -> Color:
        """Get associated color object."""
        return self._color_obj
def format_with_pretty(console: Console, obj: _cribo.typing.Any) -> str:
    """Format object using pretty printer."""
    return pkg.pretty.format_pretty(obj, console)
def apply_color_to_console(console, color: Color) -> None:
    """Apply color to console."""
    pass
def color_from_style(style) -> "Color":
    """Create a color from a style."""
    if style.color == "red":
        return Color(255, 0, 0)
    elif style.color == "green":
        return Color(0, 255, 0)
    elif style.color == "blue":
        return Color(0, 0, 255)
    return Color()
RichRenderable.__module__ = 'pkg.abc'
"""Module with stdlib-conflicting name that imports from stdlib abc."""
"""Package with circular dependencies and stdlib-conflicting module names."""
ConsoleBase.__module__ = 'pkg.console'
Console.__module__ = 'pkg.console'
"""Console module that has circular dependencies with abc and pretty."""
Color.__module__ = 'pkg.color'
"""Color module that participates in circular dependencies."""
Style.__module__ = 'pkg.style'
"""Style module that participates in circular dependencies."""
pkg_abc = _cribo.types.SimpleNamespace(__name__='pkg.abc')
pkg.abc = pkg_abc
pkg_console = _cribo.types.SimpleNamespace(__name__='pkg.console')
pkg.console = pkg_console
pkg_color = _cribo.types.SimpleNamespace(__name__='pkg.color')
pkg.color = pkg_color
pkg_style = _cribo.types.SimpleNamespace(__name__='pkg.style')
pkg.style = pkg_style
@_cribo.functools.cache
def _cribo_init___cribo_2353ad_pkg_pretty():
    _cribo_module = _cribo.types.SimpleNamespace()
    _cribo_module.__name__ = 'pkg.pretty'
    """Pretty printing module with circular dependency on console."""
    Any = _cribo.typing.Any
    _cribo_module.Any = Any
    _cribo_module.RichRenderable = RichRenderable
    _cribo_module.Console = Console

    class PrettyPrinter(RichRenderable):
        """Pretty printer that implements RichRenderable."""

        def __init__(self):
            self._indent = 2

        def render(self, console: Console) -> str:
            """Render for console output."""
            return f"PrettyPrinter(indent={self._indent})"

        def pretty_print(self, obj: _cribo.typing.Any) -> None:
            """Pretty print an object."""
            console = Console()
            formatted = format_pretty(obj, console)
            print(formatted)
    PrettyPrinter.__module__ = 'pkg.pretty'
    _cribo_module.PrettyPrinter = PrettyPrinter

    def format_pretty(obj: _cribo.typing.Any, console: Console) -> str:
        """Format object for pretty printing."""
        if console.is_renderable(obj):
            return f"<Renderable: {obj}>"
        return repr(obj)
    _cribo_module.format_pretty = format_pretty
    _cribo_module.Any = _cribo.typing.Any
    return _cribo_module
pkg.pretty = _cribo_init___cribo_2353ad_pkg_pretty()
pkg_abc.RichRenderable = RichRenderable
pkg_console.format_with_pretty = format_with_pretty
pkg_console.ConsoleBase = ConsoleBase
pkg_console.Console = Console
pkg_color.apply_color_to_console = apply_color_to_console
pkg_color.color_from_style = color_from_style
pkg_color.Color = Color
pkg_style.Style = Style
"""Test circular dependencies with stdlib-conflicting module names.\n\nThis fixture tests the bundler's ability to handle:\n1. A local module named 'abc' that conflicts with stdlib 'abc'\n2. Circular dependencies that require wrapper functions\n3. Proper stdlib normalization when hard dependencies are involved\n4. Ensuring no incorrect imports are generated for stdlib or bundled modules\n"""
PrettyPrinter = pkg.pretty.PrettyPrinter
console = Console()
console.print("Hello from main!")
pp = PrettyPrinter()
pp.pretty_print({"test": "data"})
print(f"RichRenderable class: {RichRenderable}")
