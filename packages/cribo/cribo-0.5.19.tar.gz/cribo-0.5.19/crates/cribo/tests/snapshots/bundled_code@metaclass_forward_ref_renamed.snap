---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/metaclass_forward_ref_renamed/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
yaml_module = _cribo.types.SimpleNamespace(__name__='yaml_module')
yaml_module_loader = _cribo.types.SimpleNamespace(__name__='yaml_module.loader')
yaml_module.loader = yaml_module_loader
class Loader:

    @classmethod
    def add_constructor(cls, tag, constructor):
        print(f"Loader: Registering {tag}")
class Dumper:

    @classmethod
    def add_representer(cls, data_type, representer):
        print(f"Dumper: Registering {data_type}")
Loader.__module__ = 'yaml_module.loader'
Dumper.__module__ = 'yaml_module.loader'
@_cribo.functools.cache
def _cribo_init___cribo_1fd8cb_yaml_module_other():
    _cribo_module = _cribo.types.SimpleNamespace()
    _cribo_module.__name__ = 'yaml_module.other'

    class YAMLObjectMetaclass(type):
        """First version of the metaclass"""
        pass
    YAMLObjectMetaclass.__module__ = 'yaml_module.other'
    _cribo_module.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """First version of YAMLObject"""
        source = "other"
    YAMLObject.__module__ = 'yaml_module.other'
    _cribo_module.YAMLObject = YAMLObject
    return _cribo_module
@_cribo.functools.cache
def _cribo_init___cribo_1309dd_yaml_module():
    _cribo_module = _cribo.types.SimpleNamespace()
    _cribo_module.__name__ = 'yaml_module'
    global Dumper, Loader
    _cribo_module.Dumper = Dumper
    _cribo_module.Loader = Loader
    """\nModule that mimics PyYAML's pattern where:\n1. It uses wildcard imports\n2. It defines YAMLObjectMetaclass and YAMLObject (causing collisions with other.py)\n3. YAMLObject references symbols from wildcard imports in its class body\n4. When bundled, the renamed class still references the original metaclass name\n"""
    yaml_module.other = _cribo_init___cribo_1fd8cb_yaml_module_other()
    OtherYAMLObject = yaml_module.other.YAMLObject
    _cribo_module.OtherYAMLObject = OtherYAMLObject
    yaml_module.other = _cribo_init___cribo_1fd8cb_yaml_module_other()
    OtherYAMLObjectMetaclass = yaml_module.other.YAMLObjectMetaclass
    _cribo_module.OtherYAMLObjectMetaclass = OtherYAMLObjectMetaclass

    class YAMLObjectMetaclass(type):
        """The metaclass for YAMLObject"""

        def __init__(cls, name, bases, kwds):
            super(YAMLObjectMetaclass, cls).__init__(name, bases, kwds)
            if "yaml_tag" in kwds and kwds["yaml_tag"] is not None:
                cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)
                cls.yaml_dumper.add_representer(cls, cls.to_yaml)
    YAMLObjectMetaclass.__module__ = 'yaml_module'
    _cribo_module.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """\n    YAMLObject that references wildcard-imported symbols in class body.\n    When bundled and renamed, this will become something like:\n    class YAMLObject_1(metaclass=YAMLObjectMetaclass):\n    But YAMLObjectMetaclass won't exist - only YAMLObjectMetaclass_1 will.\n    """
        __slots__ = ()
        yaml_loader = Loader
        yaml_dumper = Dumper
        yaml_tag = None

        @classmethod
        def from_yaml(cls, loader, node):
            return f"Loading {cls.__name__}"

        @classmethod
        def to_yaml(cls, dumper, data):
            return f"Dumping {cls.__name__}"
    YAMLObject.__module__ = 'yaml_module'
    _cribo_module.YAMLObject = YAMLObject
    _cribo_module.loader = yaml_module_loader
    return _cribo_module
yaml_module_loader.Loader = Loader
yaml_module_loader.Dumper = Dumper
"""\nTest case that reproduces the PyYAML metaclass renaming bug.\n\nExpected behavior: The bundled code should work correctly.\nActual behavior: NameError because renamed class references original metaclass name.\n"""
__cribo_init_result = _cribo_init___cribo_1309dd_yaml_module()
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(yaml_module, attr, getattr(__cribo_init_result, attr))
print("Module loaded successfully")
print(f"OtherYAMLObject source: {yaml_module.OtherYAMLObject.source}")
print(f"YAMLObject name: {yaml_module.YAMLObject.__name__}")
class MyYAML(yaml_module.YAMLObject):
    yaml_tag = "!my"
print("Created subclass successfully")
print(f"Loader: {yaml_module.Loader.__name__}")
print(f"Dumper: {yaml_module.Dumper.__name__}")
print("All tests passed!")
