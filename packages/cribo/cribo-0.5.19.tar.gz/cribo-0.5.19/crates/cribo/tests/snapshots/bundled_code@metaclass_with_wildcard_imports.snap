---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/metaclass_with_wildcard_imports/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
yaml_pkg = _cribo.types.SimpleNamespace(__name__='yaml_pkg')
yaml_pkg_dumper = _cribo.types.SimpleNamespace(__name__='yaml_pkg.dumper')
yaml_pkg.dumper = yaml_pkg_dumper
yaml_pkg_loader = _cribo.types.SimpleNamespace(__name__='yaml_pkg.loader')
yaml_pkg.loader = yaml_pkg_loader
class Dumper:
    """Dumper class for YAML output"""

    def __init__(self):
        self.name = "Dumper"

    @classmethod
    def add_representer(cls, data_type, representer):
        print(f"{cls.__name__}: Adding representer for {data_type}")
class BaseLoader:
    """Base loader class"""

    def __init__(self):
        self.name = "BaseLoader"

    @classmethod
    def add_constructor(cls, tag, constructor):
        print(f"{cls.__name__}: Adding constructor for {tag}")
class Loader(BaseLoader):
    """Standard loader class"""

    def __init__(self):
        super().__init__()
        self.name = "Loader"
class FullLoader(BaseLoader):
    """Full loader with all features"""

    def __init__(self):
        super().__init__()
        self.name = "FullLoader"
Dumper.__module__ = 'yaml_pkg.dumper'
BaseLoader.__module__ = 'yaml_pkg.loader'
Loader.__module__ = 'yaml_pkg.loader'
FullLoader.__module__ = 'yaml_pkg.loader'
@_cribo.functools.cache
def _cribo_init___cribo_5b2acd_yaml_pkg():
    _cribo_module = _cribo.types.SimpleNamespace()
    _cribo_module.__name__ = 'yaml_pkg'
    global BaseLoader, Dumper, FullLoader, Loader
    _cribo_module.BaseLoader = BaseLoader
    _cribo_module.Dumper = Dumper
    _cribo_module.FullLoader = FullLoader
    _cribo_module.Loader = Loader

    class YAMLObjectMetaclass(type):
        """\n    The metaclass for YAMLObject.\n    """

        def __init__(cls, name, bases, kwds):
            super(YAMLObjectMetaclass, cls).__init__(name, bases, kwds)
            if "yaml_tag" in kwds and kwds.get("yaml_tag") is not None:
                if isinstance(cls.yaml_loader, list):
                    for loader in cls.yaml_loader:
                        print(f"Registering {name} with {loader.__name__}")
                else:
                    print(f"Registering {name} with {cls.yaml_loader.__name__}")
    YAMLObjectMetaclass.__module__ = 'yaml_pkg'
    _cribo_module.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """\n    An object that uses a metaclass and references classes from wildcard imports.\n    This mimics PyYAML's structure.\n    """
        __slots__ = ()
        yaml_loader = [Loader, FullLoader]
        yaml_dumper = Dumper
        yaml_tag = None

        @classmethod
        def from_yaml(cls, loader, node):
            return f"Loading {cls.__name__} from YAML"

        @classmethod
        def to_yaml(cls, dumper, data):
            return f"Dumping {cls.__name__} to YAML"
    YAMLObject.__module__ = 'yaml_pkg'
    _cribo_module.YAMLObject = YAMLObject
    _cribo_module.dumper = yaml_pkg_dumper
    _cribo_module.loader = yaml_pkg_loader
    return _cribo_module
yaml_pkg_dumper.Dumper = Dumper
yaml_pkg_loader.BaseLoader = BaseLoader
yaml_pkg_loader.Loader = Loader
yaml_pkg_loader.FullLoader = FullLoader
"""\nTest case for metaclass forward reference issue with wildcard imports.\n\nThis reproduces the PyYAML bundling issue where:\n1. A class uses a metaclass that's defined later in the same module\n2. The class body references symbols imported via wildcard imports\n3. When bundled, the metaclass definition gets placed after its usage\n"""
yaml_pkg = _cribo_init___cribo_5b2acd_yaml_pkg()
print("Module loaded successfully")
print(f"YAMLObject name: {yaml_pkg.YAMLObject.__name__}")
print(f"YAMLObjectMetaclass name: {yaml_pkg.YAMLObjectMetaclass.__name__}")
print(f"Loader name: {yaml_pkg.Loader.__name__}")
print(f"FullLoader name: {yaml_pkg.FullLoader.__name__}")
print(f"Dumper name: {yaml_pkg.Dumper.__name__}")
class CustomYAMLObject(yaml_pkg.YAMLObject):
    yaml_tag = "!custom"

    def __init__(self, value):
        self.value = value
obj = CustomYAMLObject("test")
print(f"Created custom object with value: {obj.value}")
print(f"Custom object class name: {obj.__class__.__name__}")
print(f"yaml_loader types: {[type(loader).__name__ for loader in CustomYAMLObject.yaml_loader]}")
print(f"yaml_dumper type: {type(CustomYAMLObject.yaml_dumper).__name__}")
