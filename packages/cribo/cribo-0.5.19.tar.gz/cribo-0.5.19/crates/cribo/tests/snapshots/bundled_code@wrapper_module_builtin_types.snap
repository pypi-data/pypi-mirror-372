---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/wrapper_module_builtin_types/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
pkg = _cribo.types.SimpleNamespace(__name__='pkg')
bytes = bytes
str = str
builtin_str = str
def process_data(data):
    """Process data using compat.bytes attribute.\n\n    This will fail when bundled because the bundler skips 'bytes = bytes'\n    in compat's init function.\n    """
    if isinstance(data, compat.bytes):
        return f"Processed {len(data)} bytes"
    elif isinstance(data, compat.str):
        return f"Processed string: {data}"
    else:
        return "Unknown type"
"""Main package that creates wrapper module pattern like requests."""
"""Sessions module that creates more circular dependencies."""
"""Models module to add more complexity."""
"""Compatibility module that matches requests.compat pattern exactly."""
"""Version info."""
"""Utils module that matches requests.utils import pattern."""
"""Certs module."""
pkg_sessions = _cribo.types.SimpleNamespace(__name__='pkg.sessions')
pkg.sessions = pkg_sessions
pkg_models = _cribo.types.SimpleNamespace(__name__='pkg.models')
pkg.models = pkg_models
pkg_compat = _cribo.types.SimpleNamespace(__name__='pkg.compat')
pkg.compat = pkg_compat
pkg___version__ = _cribo.types.SimpleNamespace(__name__='pkg.__version__')
pkg.__version__ = pkg___version__
pkg_utils = _cribo.types.SimpleNamespace(__name__='pkg.utils')
pkg.utils = pkg_utils
pkg_certs = _cribo.types.SimpleNamespace(__name__='pkg.certs')
pkg.certs = pkg_certs
@_cribo.functools.cache
def _cribo_init___cribo_5a392a_pkg__internal_utils():
    _cribo_module = _cribo.types.SimpleNamespace()
    _cribo_module.__name__ = 'pkg._internal_utils'
    """Internal utils that depends on compat, creating circular dependency."""
    _cribo_module.builtin_str = builtin_str
    HEADER_VALIDATORS = {"str": lambda x: isinstance(x, builtin_str), "bytes": lambda x: isinstance(x, bytes)}
    _cribo_module.HEADER_VALIDATORS = HEADER_VALIDATORS

    def to_native_string(value):
        """Convert to native string."""
        if isinstance(value, builtin_str):
            return value
        return str(value)
    _cribo_module.to_native_string = to_native_string
    return _cribo_module
pkg._internal_utils = _cribo_init___cribo_5a392a_pkg__internal_utils()
utils = pkg_utils
compat = pkg_compat
pkg_utils.process_data = process_data
pkg_compat.builtin_str = builtin_str
pkg_compat.bytes = bytes
pkg_compat.str = str
_internal_utils = pkg._internal_utils
"""Test wrapper module pattern that triggers init functions with builtin types bug.\n\nThis reproduces the exact pattern from requests where:\n1. Multiple modules form circular dependencies (wrapper modules)\n2. One wrapper module (compat) has self-referential builtin assignments\n3. Another wrapper module (utils) accesses these as attributes\n4. The bundler generates init functions for wrapper modules\n"""
pkg.process_data = process_data
result = pkg.process_data(b"test")
print(f"Result: {result}")
print("Success!")
