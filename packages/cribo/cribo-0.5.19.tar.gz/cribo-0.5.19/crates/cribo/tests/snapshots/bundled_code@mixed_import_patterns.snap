---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/mixed_import_patterns/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
_logger = None
_config = None
class Application:

    def __init__(self):
        self.config = get_config()
        self.logger = get_logger()
        self.logger.log(f"Creating {self.config.app_name} v{self.config.version} application instance")

    def run(self):
        """Run the application with various logging examples"""
        self.logger.log("Application.run() called", "DEBUG")
        print(format_message("Performing application tasks..."))
        self.demonstrate_import_patterns()
        self.logger.log("Application tasks completed", "INFO")

    def demonstrate_import_patterns(self):
        """Show how the same module can be imported different ways"""
        self.logger.log("Using module-level logger import", "DEBUG")
        print(format_message("Mixed import patterns working correctly!"))
        local_logger = get_logger()
        local_logger.log("Function-level import gives same logger instance", "DEBUG")
class Logger:

    def __init__(self):
        self.log_level = "INFO"
        print(format_message("[Logger] Initializing logger system"))

    def configure(self):
        """Configure logger with settings from config module"""
        self.log_level = get_log_level()
        self.log(f"Logger configured with level: {self.log_level}")

    def log(self, message, level="INFO"):
        if self._should_log(level):
            print(f"[{level}] {message}")

    def _should_log(self, level):
        levels = {"DEBUG": 0, "INFO": 1, "WARNING": 2, "ERROR": 3}
        return levels.get(level, 1) >= levels.get(self.log_level, 1)
class Config:

    def __init__(self):
        self.debug_mode = True
        self.app_name = "CircularImportDemo"
        self.version = "1.0.0"
        self._logger_configured = False
        logger = get_logger()
        logger.log("Initializing configuration system")

    def ensure_logger_configured(self):
        """Configure logger after config is ready"""
        if not self._logger_configured:
            logger = get_logger()
            logger.configure()
            logger.log("Configuration system initialized", "INFO")
            self._logger_configured = True

    def get_setting(self, key):
        return getattr(self, key, None)
def get_logger():
    global _logger
    if _logger is None:
        _logger = Logger()
    return _logger
def get_log_level():
    """Get log level from config - used by logger module"""
    if _config is None:
        return "INFO"
    return "DEBUG" if _config.debug_mode else "INFO"
def get_config():
    global _config
    if _config is None:
        _config = Config()
    return _config
def format_message(message):
    """Format a message with decorative borders"""
    return f">>> {message} <<<"
"""\nApplication module that uses both config and logger.\nNo circular dependencies here - just normal imports.\n"""
Application.__module__ = 'app'
Logger.__module__ = 'logger'
"""\nLogger module that needs configuration to determine log level.\nThis creates a circular dependency: logger -> config -> logger\n"""
Config.__module__ = 'config'
"""\nConfiguration module that logs its initialization process.\nThis creates a circular dependency: config -> logger -> config\n"""
"""\nUtility module with no dependencies on other modules in this package.\nThis can be safely imported at module level by everyone.\n"""
config = _cribo.types.SimpleNamespace(__name__='config')
logger = _cribo.types.SimpleNamespace(__name__='logger')
utils = _cribo.types.SimpleNamespace(__name__='utils')
logger.get_logger = get_logger
logger._logger = _logger
logger.Logger = Logger
config.get_log_level = get_log_level
config.get_config = get_config
config._config = _config
config.Config = Config
utils.format_message = format_message
"""\nSimulates a software architecture with:\n- A logger that needs configuration\n- A configuration system that logs its initialization\n- An application that uses both\n- Utilities that are used everywhere (no circular deps)\n"""
def main():
    print(format_message("=== Application Starting ==="))
    config = Config()
    config.ensure_logger_configured()
    print(format_message(f"Configuration loaded: debug={config.debug_mode}"))
    app = Application()
    app.run()
    print(format_message("=== Application Finished ==="))
if __name__ == "__main__":
    main()
