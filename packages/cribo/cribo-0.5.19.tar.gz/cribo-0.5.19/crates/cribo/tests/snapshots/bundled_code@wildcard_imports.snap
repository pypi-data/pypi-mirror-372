---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/wildcard_imports/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
SHARED_CONSTANT_1 = "SHARED_FROM_B"
SHARED_CONSTANT_2 = "SHARED_FROM_A"
SAFE_CONSTANT = "SAFE_VALUE"
class SharedClass_1:
    """Class with same name in multiple modules."""

    def method(self):
        return "SharedClass_from_module_b"
class SharedClass_2:
    """Class with same name in multiple modules."""

    def method(self):
        return "SharedClass_from_module_a"
class SafeClass:
    """A class that will be exported via __all__."""

    def method(self):
        return "SafeClass.method_result"
def shared_function_1():
    """Function with same name in multiple modules."""
    return "shared_function_from_module_b"
def unique_b_function():
    """Function unique to module B."""
    return "unique_b_result"
def shared_function_2():
    """Function with same name in multiple modules."""
    return "shared_function_from_module_a"
def unique_a_function():
    """Function unique to module A."""
    return "unique_a_result"
def safe_function():
    """A function that will be exported via __all__."""
    return "safe_function_result"
"""Second module with potentially clashing names (no side-effects)."""
SharedClass_1.__module__ = 'clash_module_b'
SharedClass_1.__name__ = 'SharedClass'
SharedClass_1.__qualname__ = 'SharedClass'
"""First module with potentially clashing names (no side-effects)."""
SharedClass_2.__module__ = 'clash_module_a'
SharedClass_2.__name__ = 'SharedClass'
SharedClass_2.__qualname__ = 'SharedClass'
"""Module with no side-effects and explicit __all__."""
SafeClass.__module__ = 'explicit_all'
@_cribo.functools.cache
def _cribo_init___cribo_9a9871_with_side_effects():
    _cribo_module = _cribo.types.SimpleNamespace()
    _cribo_module.__name__ = 'with_side_effects'
    """Module with side-effects and no explicit __all__."""
    print("Loading with_side_effects module")
    _module_state = []
    _cribo_module._module_state = _module_state
    _cribo_module._module_state.append("initialized")

    def effect_function():
        """Function from module with side-effects."""
        return "effect_function_result"
    _cribo_module.effect_function = effect_function

    class EffectClass:
        """Class from module with side-effects."""
        instances = []

        def __init__(self):
            self.instances.append(self)

        def method(self):
            return "EffectClass.method_result"
    EffectClass.__module__ = 'with_side_effects'
    _cribo_module.EffectClass = EffectClass
    EFFECT_CONSTANT = "EFFECT_VALUE"
    _cribo_module.EFFECT_CONSTANT = EFFECT_CONSTANT
    _registry = {}
    _cribo_module._registry = _registry

    def register(name):
        """Decorator with side-effects."""

        def decorator(func):
            _cribo_module._registry[name] = func
            return func
        return decorator
    _cribo_module.register = register

    @register("sample")
    def registered_function():
        """Function registered as a side-effect."""
        return "registered_result"
    _cribo_module.registered_function = registered_function
    if len(_cribo_module._module_state) > 0:
        print(f"Module state initialized with {len(_module_state)} items")
    return _cribo_module
"""Main module demonstrating various wildcard import patterns."""
with_side_effects = _cribo_init___cribo_9a9871_with_side_effects()
EFFECT_CONSTANT = with_side_effects.EFFECT_CONSTANT
EffectClass = with_side_effects.EffectClass
effect_function = with_side_effects.effect_function
register = with_side_effects.register
registered_function = with_side_effects.registered_function
shared_function = shared_function_2
SharedClass = SharedClass_2
SHARED_CONSTANT = SHARED_CONSTANT_2
shared_function = shared_function_1
SharedClass = SharedClass_1
SHARED_CONSTANT = SHARED_CONSTANT_1
def main():
    """Test all imported symbols."""
    results = []
    results.append(f"safe_function: {safe_function()}")
    results.append(f"SafeClass: {SafeClass().method()}")
    results.append(f"SAFE_CONSTANT: {SAFE_CONSTANT}")
    try:
        results.append(f"_private_function: {_private_function()}")
    except NameError:
        results.append("_private_function: correctly not imported")
    try:
        results.append(f"PRIVATE_CONSTANT: {PRIVATE_CONSTANT}")
    except NameError:
        results.append("PRIVATE_CONSTANT: correctly not imported")
    results.append(f"effect_function: {effect_function()}")
    results.append(f"EffectClass: {EffectClass().method()}")
    results.append(f"EFFECT_CONSTANT: {EFFECT_CONSTANT}")
    results.append(f"registered_function: {registered_function()}")
    results.append(f"shared_function: {shared_function()}")
    results.append(f"SharedClass: {SharedClass().method()}")
    results.append(f"SHARED_CONSTANT: {SHARED_CONSTANT}")
    results.append(f"unique_a_function: {unique_a_function()}")
    results.append(f"unique_b_function: {unique_b_function()}")
    return results
if __name__ == "__main__":
    print("Testing wildcard imports:")
    print("-" * 40)
    for result in main():
        print(result)
    print("-" * 40)
    print("All tests completed!")
