from typing import Any, Optional, List, Dict, Tuple, Callable, Union

"""Contains the definition of range_t.

A range is a non-empty continuous range of addresses (specified by its start and end addresses, the end address is excluded from the range).
Ranges are stored in the Btree part of the IDA database. To learn more about Btrees (Balanced Trees): [http://www.bluerwhite.org/btree/](http://www.bluerwhite.org/btree/) 
    
"""

class array_of_rangesets:
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: array_of_rangesets) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> bool: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> rangeset_t: ...
    def __gt__(self, value: Any) -> bool: ...
        """Return self>value."""
    def __init__(self, args: Any) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> bool: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> bool: ...
        """Return self<value."""
    def __ne__(self, r: array_of_rangesets) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: rangeset_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: rangeset_t) -> bool: ...
    def append(self, x: rangeset_t) -> None: ...
    def at(self, _idx: size_t) -> rangeset_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> rangeset_t: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> rangeset_t: ...
    def erase(self, args: Any) -> qvector< rangeset_t >: ...
    def extend(self, x: array_of_rangesets) -> None: ...
    def extract(self) -> rangeset_t *: ...
    def find(self, args: Any) -> qvector< rangeset_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: rangeset_t) -> bool: ...
    def inject(self, s: rangeset_t, len: size_t) -> None: ...
    def insert(self, it: rangeset_t, x: rangeset_t) -> qvector< rangeset_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> rangeset_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: array_of_rangesets) -> None: ...
    def truncate(self) -> None: ...

class range_t:
    @property
    def end_ea(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: range_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, r: range_t) -> bool: ...
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __gt__(self, r: range_t) -> bool: ...
    def __init__(self, ea1: int = 0, ea2: int = 0) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __le__(self, r: range_t) -> bool: ...
    def __lt__(self, r: range_t) -> bool: ...
    def __ne__(self, r: range_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def clear(self) -> None: ...
        """Set start_ea, end_ea to 0.
        
        """
    def compare(self, r: range_t) -> int: ...
    def contains(self, args: Any) -> bool: ...
        """This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
    def empty(self) -> bool: ...
        """Is the size of the range_t <= 0?
        
        """
    def extend(self, ea: int) -> None: ...
        """Ensure that the range_t includes 'ea'.
        
        """
    def intersect(self, r: range_t) -> bool: ...
        """Assign the range_t to the intersection between the range_t and 'r'.
        
        """
    def overlaps(self, r: range_t) -> bool: ...
        """Is there an ea in 'r' that is also in this range_t?
        
        """
    def size(self) -> int: ...
        """Get end_ea - start_ea.
        
        """

class rangeset_t:
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, aset: rangeset_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> bool: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, idx: Any) -> rangeset_t: ...
    def __gt__(self, value: Any) -> bool: ...
        """Return self>value."""
    def __init__(self, args: Any) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> bool: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
        """Get the number of range_t elements in the set.
        
        """
    def __lt__(self, value: Any) -> bool: ...
        """Return self<value."""
    def __ne__(self, aset: rangeset_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add(self, args: Any) -> bool: ...
        """This function has the following signatures:
        
            0. add(range: const range_t &) -> bool
            1. add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
            2. add(aset: const rangeset_t &) -> bool
        
        # 0: add(range: const range_t &) -> bool
        
        Add an address range to the set. If 'range' intersects an existing element e, then e is extended to include 'range', and any superfluous elements (subsets of e) are removed. 
                
        @returns false if 'range' was not added (the set was unchanged)
        
        # 1: add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
        
        Create a new range_t from 'start' and 'end' and add it to the set.
        
        
        # 2: add(aset: const rangeset_t &) -> bool
        
        Add each element of 'aset' to the set. 
                
        @returns false if no elements were added (the set was unchanged)
        
        """
    def begin(self) -> rangeset_t: ...
        """Get an iterator that points to the first element in the set.
        
        """
    def cached_range(self) -> range_t const *: ...
        """When searching the rangeset, we keep a cached element to help speed up searches. 
                
        @returns a pointer to the cached element
        """
    def clear(self) -> None: ...
        """Delete all elements from the set. See qvector::clear()
        
        """
    def contains(self, args: Any) -> bool: ...
        """This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(aset: const rangeset_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Does an element of the rangeset contain 'ea'? See range_t::contains(ea_t)
        
        
        # 1: contains(aset: const rangeset_t &) -> bool
        
        Is every element in 'aset' contained in an element of this rangeset?. See range_t::contains(range_t)
        
        
        """
    def empty(self) -> bool: ...
        """Does the set have zero elements.
        
        """
    def end(self) -> rangeset_t: ...
        """Get an iterator that points to the end of the set. (This is NOT the last element)
        
        """
    def find_range(self, ea: int) -> range_t const *: ...
        """Get the element from the set that contains 'ea'. 
                
        @returns nullptr if there is no such element
        """
    def getrange(self, idx: int) -> range_t: ...
        """Get the range_t at index 'idx'.
        
        """
    def has_common(self, args: Any) -> bool: ...
        """This function has the following signatures:
        
            0. has_common(range: const range_t &) -> bool
            1. has_common(aset: const rangeset_t &) -> bool
        
        # 0: has_common(range: const range_t &) -> bool
        
        Is there an ea in 'range' that is also in the rangeset?
        
        
        # 1: has_common(aset: const rangeset_t &) -> bool
        
        Does any element of 'aset' overlap with an element in this rangeset?. See range_t::overlaps()
        
        
        """
    def includes(self, range: range_t) -> bool: ...
        """Is every ea in 'range' contained in the rangeset?
        
        """
    def intersect(self, aset: rangeset_t) -> bool: ...
        """Set the rangeset to its intersection with 'aset'. 
                
        @returns false if the set was unchanged
        """
    def is_equal(self, aset: rangeset_t) -> bool: ...
        """Do this rangeset and 'aset' have identical elements?
        
        """
    def is_subset_of(self, aset: rangeset_t) -> bool: ...
        """Is every element in the rangeset contained in an element of 'aset'?
        
        """
    def lastrange(self) -> range_t: ...
        """Get the last range_t in the set.
        
        """
    def next_addr(self, ea: int) -> ida_idaapi.ea_t: ...
        """Get the smallest ea_t value greater than 'ea' contained in the rangeset.
        
        """
    def next_range(self, ea: int) -> ida_idaapi.ea_t: ...
        """Get the smallest ea_t value greater than 'ea' that is not in the same range as 'ea'.
        
        """
    def nranges(self) -> int: ...
        """Get the number of range_t elements in the set.
        
        """
    def prev_addr(self, ea: int) -> ida_idaapi.ea_t: ...
        """Get the largest ea_t value less than 'ea' contained in the rangeset.
        
        """
    def prev_range(self, ea: int) -> ida_idaapi.ea_t: ...
        """Get the largest ea_t value less than 'ea' that is not in the same range as 'ea'.
        
        """
    def sub(self, args: Any) -> bool: ...
        """This function has the following signatures:
        
            0. sub(range: const range_t &) -> bool
            1. sub(ea: ida_idaapi.ea_t) -> bool
            2. sub(aset: const rangeset_t &) -> bool
        
        # 0: sub(range: const range_t &) -> bool
        
        Subtract an address range from the set. All subsets of 'range' will be removed, and all elements that intersect 'range' will be truncated/split so they do not include 'range'. 
                
        @returns false if 'range' was not subtracted (the set was unchanged)
        
        # 1: sub(ea: ida_idaapi.ea_t) -> bool
        
        Subtract an ea (an range of size 1) from the set. See sub(const range_t &)
        
        
        # 2: sub(aset: const rangeset_t &) -> bool
        
        Subtract each range in 'aset' from the set 
                
        @returns false if nothing was subtracted (the set was unchanged)
        
        """
    def swap(self, r: rangeset_t) -> None: ...
        """Set this = 'r' and 'r' = this. See qvector::swap()
        
        """

class rangevec_base_t:
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: rangevec_base_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> bool: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> rangeset_t: ...
    def __gt__(self, value: Any) -> bool: ...
        """Return self>value."""
    def __init__(self, args: Any) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> bool: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> bool: ...
        """Return self<value."""
    def __ne__(self, r: rangevec_base_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: range_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: range_t) -> bool: ...
    def append(self, x: range_t) -> None: ...
    def at(self, _idx: size_t) -> rangeset_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> rangeset_t: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> rangeset_t: ...
    def erase(self, args: Any) -> qvector< rangeset_t >: ...
    def extend(self, x: rangevec_base_t) -> None: ...
    def extract(self) -> rangeset_t *: ...
    def find(self, args: Any) -> qvector< rangeset_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: range_t) -> bool: ...
    def inject(self, s: range_t, len: size_t) -> None: ...
    def insert(self, it: range_t, x: range_t) -> qvector< rangeset_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> rangeset_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: rangevec_base_t) -> None: ...
    def truncate(self) -> None: ...

class rangevec_t(rangevec_base_t):
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: rangevec_base_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> bool: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> rangeset_t: ...
    def __gt__(self, value: Any) -> bool: ...
        """Return self>value."""
    def __init__(self) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> bool: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> bool: ...
        """Return self<value."""
    def __ne__(self, r: rangevec_base_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: range_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: range_t) -> bool: ...
    def append(self, x: range_t) -> None: ...
    def at(self, _idx: size_t) -> rangeset_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> rangeset_t: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> rangeset_t: ...
    def erase(self, args: Any) -> qvector< rangeset_t >: ...
    def extend(self, x: rangevec_base_t) -> None: ...
    def extract(self) -> rangeset_t *: ...
    def find(self, args: Any) -> qvector< rangeset_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: range_t) -> bool: ...
    def inject(self, s: range_t, len: size_t) -> None: ...
    def insert(self, it: range_t, x: range_t) -> qvector< rangeset_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> rangeset_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: rangevec_base_t) -> None: ...
    def truncate(self) -> None: ...

def List(args: Any, kwargs: Any) -> Any: ...
    """A generic version of list."""

def Tuple(args: Any, kwargs: Any) -> Any: ...
    """Tuple type; Tuple[X, Y] is the cross-product type of X and Y.
    
        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.
    
        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
        
    """

def Union(args: Any, kwds: Any) -> Any: ...
    """Union type; Union[X, Y] means either X or Y.
    
        To define a union, use e.g. Union[int, str].  Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::
    
            Union[Union[int, str], float] == Union[int, str, float]
    
        - Unions of a single argument vanish, e.g.::
    
            Union[int] == int  # The constructor actually returns int
    
        - Redundant arguments are skipped, e.g.::
    
            Union[int, str, int] == Union[int, str]
    
        - When comparing unions, the argument order is ignored, e.g.::
    
            Union[int, str] == Union[str, int]
    
        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].
        
    """

def range_t_print(cb: range_t) -> str: ...
    """Helper function. Should not be called directly!
    
    """

RANGE_KIND_FUNC: int  # 1
RANGE_KIND_HIDDEN_RANGE: int  # 3
RANGE_KIND_SEGMENT: int  # 2
RANGE_KIND_UNKNOWN: int  # 0
SWIG_PYTHON_LEGACY_BOOL: int  # 1
ida_idaapi: module
weakref: module