from typing import Any, Optional, List, Dict, Tuple, Callable, Union

"""Architecture independent exception handling info.

Try blocks have the following general properties:
* A try block specifies a possibly fragmented guarded code region.
* Each try block has always at least one catch/except block description
* Each catch block contains its boundaries and a filter.
* Additionally a catch block can hold sp adjustment and the offset to the exception object offset (C++).
* Try blocks can be nested. Nesting is automatically calculated at the retrieval time.
* There may be (nested) multiple try blocks starting at the same address.


See examples in tests/input/src/eh_tests. 
    
"""

class catch_t(try_handler_t):
    @property
    def disp(self) -> Any: ...
    @property
    def fpreg(self) -> Any: ...
    @property
    def obj(self) -> Any: ...
    @property
    def type_id(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: rangevec_base_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> Any: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> catch_t: ...
    def __gt__(self, value: Any) -> Any: ...
        """Return self>value."""
    def __init__(self) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> Any: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> Any: ...
        """Return self<value."""
    def __ne__(self, r: rangevec_base_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: range_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: range_t) -> bool: ...
    def append(self, x: range_t) -> None: ...
    def at(self, _idx: size_t) -> catch_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> qvector< catch_t >: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> qvector< catch_t >: ...
    def erase(self, args: Any) -> qvector< catch_t >: ...
    def extend(self, x: rangevec_base_t) -> None: ...
    def extract(self) -> catch_t *: ...
    def find(self, args: Any) -> qvector< catch_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: range_t) -> bool: ...
    def inject(self, s: range_t, len: size_t) -> None: ...
    def insert(self, it: range_t, x: range_t) -> qvector< catch_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> catch_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: rangevec_base_t) -> None: ...
    def truncate(self) -> None: ...

class catchvec_t:
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: catchvec_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> Any: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> catch_t: ...
    def __gt__(self, value: Any) -> Any: ...
        """Return self>value."""
    def __init__(self, args: Any) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> Any: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> Any: ...
        """Return self<value."""
    def __ne__(self, r: catchvec_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: catch_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: catch_t) -> bool: ...
    def append(self, x: catch_t) -> None: ...
    def at(self, _idx: size_t) -> catch_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> qvector< catch_t >: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> qvector< catch_t >: ...
    def erase(self, args: Any) -> qvector< catch_t >: ...
    def extend(self, x: catchvec_t) -> None: ...
    def extract(self) -> catch_t *: ...
    def find(self, args: Any) -> qvector< catch_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: catch_t) -> bool: ...
    def inject(self, s: catch_t, len: size_t) -> None: ...
    def insert(self, it: catch_t, x: catch_t) -> qvector< catch_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> catch_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: catchvec_t) -> None: ...
    def truncate(self) -> None: ...

class seh_t(try_handler_t):
    @property
    def disp(self) -> Any: ...
    @property
    def filter(self) -> Any: ...
    @property
    def fpreg(self) -> Any: ...
    @property
    def seh_code(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: rangevec_base_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> Any: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> catch_t: ...
    def __gt__(self, value: Any) -> Any: ...
        """Return self>value."""
    def __init__(self) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> Any: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> Any: ...
        """Return self<value."""
    def __ne__(self, r: rangevec_base_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: range_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: range_t) -> bool: ...
    def append(self, x: range_t) -> None: ...
    def at(self, _idx: size_t) -> catch_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> qvector< catch_t >: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> qvector< catch_t >: ...
    def erase(self, args: Any) -> qvector< catch_t >: ...
    def extend(self, x: rangevec_base_t) -> None: ...
    def extract(self) -> catch_t *: ...
    def find(self, args: Any) -> qvector< catch_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: range_t) -> bool: ...
    def inject(self, s: range_t, len: size_t) -> None: ...
    def insert(self, it: range_t, x: range_t) -> qvector< catch_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> catch_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: rangevec_base_t) -> None: ...
    def truncate(self) -> None: ...

class try_handler_t:
    @property
    def disp(self) -> Any: ...
    @property
    def fpreg(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: rangevec_base_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> Any: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> catch_t: ...
    def __gt__(self, value: Any) -> Any: ...
        """Return self>value."""
    def __init__(self) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> Any: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> Any: ...
        """Return self<value."""
    def __ne__(self, r: rangevec_base_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: range_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: range_t) -> bool: ...
    def append(self, x: range_t) -> None: ...
    def at(self, _idx: size_t) -> catch_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> qvector< catch_t >: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> qvector< catch_t >: ...
    def erase(self, args: Any) -> qvector< catch_t >: ...
    def extend(self, x: rangevec_base_t) -> None: ...
    def extract(self) -> catch_t *: ...
    def find(self, args: Any) -> qvector< catch_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: range_t) -> bool: ...
    def inject(self, s: range_t, len: size_t) -> None: ...
    def insert(self, it: range_t, x: range_t) -> qvector< catch_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> catch_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: rangevec_base_t) -> None: ...
    def truncate(self) -> None: ...

class tryblk_t:
    @property
    def level(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: rangevec_base_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> Any: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> catch_t: ...
    def __gt__(self, value: Any) -> Any: ...
        """Return self>value."""
    def __init__(self, args: Any) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> Any: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> Any: ...
        """Return self<value."""
    def __ne__(self, r: rangevec_base_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: range_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: range_t) -> bool: ...
    def append(self, x: range_t) -> None: ...
    def at(self, _idx: size_t) -> catch_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> qvector< catch_t >: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def cpp(self) -> catchvec_t &: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> qvector< catch_t >: ...
    def erase(self, args: Any) -> qvector< catch_t >: ...
    def extend(self, x: rangevec_base_t) -> None: ...
    def extract(self) -> catch_t *: ...
    def find(self, args: Any) -> qvector< catch_t >: ...
    def front(self) -> Any: ...
    def get_kind(self) -> uchar: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: range_t) -> bool: ...
    def inject(self, s: range_t, len: size_t) -> None: ...
    def insert(self, it: range_t, x: range_t) -> qvector< catch_t >: ...
    def is_cpp(self) -> bool: ...
    def is_seh(self) -> bool: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> catch_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def seh(self) -> seh_t &: ...
    def set_cpp(self) -> catchvec_t &: ...
    def set_seh(self) -> seh_t &: ...
    def size(self) -> int: ...
    def swap(self, r: rangevec_base_t) -> None: ...
    def truncate(self) -> None: ...

class tryblks_t:
    def __delattr__(self, name: Any) -> Any: ...
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any: ...
        """Default dir() implementation."""
    def __eq__(self, r: tryblks_t) -> bool: ...
    def __format__(self, format_spec: Any) -> Any: ...
        """Default object formatter."""
    def __ge__(self, value: Any) -> Any: ...
        """Return self>=value."""
    def __getattribute__(self, name: Any) -> Any: ...
        """Return getattr(self, name)."""
    def __getitem__(self, i: size_t) -> catch_t: ...
    def __gt__(self, value: Any) -> Any: ...
        """Return self>value."""
    def __init__(self, args: Any) -> Any: ...
    def __init_subclass__(self, *args: Any, **kwargs: Any) -> Any: ...
        """This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
    def __iter__(self) -> Any: ...
        """Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
    def __le__(self, value: Any) -> Any: ...
        """Return self<=value."""
    def __len__(self) -> int: ...
    def __lt__(self, value: Any) -> Any: ...
        """Return self<value."""
    def __ne__(self, r: tryblks_t) -> bool: ...
    def __new__(self, args: Any, kwargs: Any) -> Any: ...
        """Create and return a new object.  See help(type) for accurate signature."""
    def __reduce__(self) -> Any: ...
        """Helper for pickle."""
    def __reduce_ex__(self, protocol: Any) -> Any: ...
        """Helper for pickle."""
    def __repr__(self) -> Any: ...
    def __setattr__(self, name: Any, value: Any) -> Any: ...
        """Implement setattr(self, name, value)."""
    def __setitem__(self, i: size_t, v: tryblk_t) -> None: ...
    def __sizeof__(self) -> Any: ...
        """Size of object in memory, in bytes."""
    def __str__(self) -> Any: ...
        """Return str(self)."""
    def __subclasshook__(self, *args: Any, **kwargs: Any) -> Any: ...
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
    def __swig_destroy__(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_unique(self, x: tryblk_t) -> bool: ...
    def append(self, x: tryblk_t) -> None: ...
    def at(self, _idx: size_t) -> catch_t: ...
    def back(self) -> Any: ...
    def begin(self, args: Any) -> qvector< catch_t >: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def end(self, args: Any) -> qvector< catch_t >: ...
    def erase(self, args: Any) -> qvector< catch_t >: ...
    def extend(self, x: tryblks_t) -> None: ...
    def extract(self) -> catch_t *: ...
    def find(self, args: Any) -> qvector< catch_t >: ...
    def front(self) -> Any: ...
    def grow(self, args: Any) -> None: ...
    def has(self, x: tryblk_t) -> bool: ...
    def inject(self, s: tryblk_t, len: size_t) -> None: ...
    def insert(self, it: tryblk_t, x: tryblk_t) -> qvector< catch_t >: ...
    def pop_back(self) -> None: ...
    def push_back(self, args: Any) -> catch_t &: ...
    def qclear(self) -> None: ...
    def reserve(self, cnt: size_t) -> None: ...
    def resize(self, args: Any) -> None: ...
    def size(self) -> int: ...
    def swap(self, r: tryblks_t) -> None: ...
    def truncate(self) -> None: ...

def List(args: Any, kwargs: Any) -> Any: ...
    """A generic version of list."""

def Tuple(args: Any, kwargs: Any) -> Any: ...
    """Tuple type; Tuple[X, Y] is the cross-product type of X and Y.
    
        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.
    
        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
        
    """

def Union(args: Any, kwds: Any) -> Any: ...
    """Union type; Union[X, Y] means either X or Y.
    
        To define a union, use e.g. Union[int, str].  Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::
    
            Union[Union[int, str], float] == Union[int, str, float]
    
        - Unions of a single argument vanish, e.g.::
    
            Union[int] == int  # The constructor actually returns int
    
        - Redundant arguments are skipped, e.g.::
    
            Union[int, str, int] == Union[int, str]
    
        - When comparing unions, the argument order is ignored, e.g.::
    
            Union[int, str] == Union[str, int]
    
        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].
        
    """

def add_tryblk(tb: tryblk_t) -> int: ...
    """Add one try block information. 
            
    @param tb: try block to add.
    @returns error code; 0 means good
    """

def del_tryblks(range: range_t) -> None: ...
    """Delete try block information in the specified range. 
            
    @param range: the range to be cleared
    """

def find_syseh(ea: int) -> ida_idaapi.ea_t: ...
    """Find the start address of the system eh region including the argument. 
            
    @param ea: search address
    @returns start address of surrounding tryblk, otherwise BADADDR
    """

def get_tryblks(tbv: tryblks_t, range: range_t) -> int: ...
    """------------------------------------------------------------------------- Retrieve try block information from the specified address range. Try blocks are sorted by starting address and their nest levels calculated. 
            
    @param tbv: output buffer; may be nullptr
    @param range: address range to change
    @returns number of found try blocks
    """

def is_ea_tryblks(ea: int, flags: int) -> bool: ...
    """Check if the given address ea is part of tryblks description. 
            
    @param ea: address to check
    @param flags: combination of flags for is_ea_tryblks()
    """

SWIG_PYTHON_LEGACY_BOOL: int  # 1
TBEA_ANY: int  # 31
TBEA_CATCH: int  # 2
TBEA_FALLTHRU: int  # 32
TBEA_SEHFILT: int  # 16
TBEA_SEHLPAD: int  # 8
TBEA_SEHTRY: int  # 4
TBEA_TRY: int  # 1
TBERR_EMPTY: int  # 4
TBERR_END: int  # 2
TBERR_INTERSECT: int  # 7
TBERR_KIND: int  # 5
TBERR_NO_CATCHES: int  # 6
TBERR_OK: int  # 0
TBERR_ORDER: int  # 3
TBERR_START: int  # 1
ida_idaapi: module
ida_range: module
weakref: module