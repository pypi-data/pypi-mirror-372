{"version":3,"file":"VivViewerMDV-D_q-5ccV.js","sources":["../../../../src/utilities/VivUtils.js","../../../../src/webgl/VivViewerMDV.js"],"sourcesContent":["import { getChannelStats } from \"@vivjs-experimental/viv\";\nimport { Matrix4 } from \"@math.gl/core\";\n\n/** copied (not quite verbatim) from avivator utils */\nexport async function getSingleSelectioStats3D(\n    loader,\n    selection = { c: 0, t: 0 },\n) {\n    const lowResSource = loader[loader.length - 1];\n    const { shape, labels } = lowResSource;\n    const sizeZ = shape[labels.indexOf(\"z\")] >> (loader.length - 1);\n    const raster0 = await lowResSource.getRaster({\n        selection: { ...selection, z: 0 },\n    });\n    const rasterMid = await lowResSource.getRaster({\n        selection: { ...selection, z: Math.floor(sizeZ / 2) },\n    });\n    const rasterTop = await lowResSource.getRaster({\n        selection: { ...selection, z: Math.max(0, sizeZ - 1) },\n    });\n    const stats0 = getChannelStats(raster0.data);\n    const statsMid = getChannelStats(rasterMid.data);\n    const statsTop = getChannelStats(rasterTop.data);\n    return {\n        domain: [\n            Math.min(stats0.domain[0], statsMid.domain[0], statsTop.domain[0]),\n            Math.max(stats0.domain[1], statsMid.domain[1], statsTop.domain[1]),\n        ],\n        contrastLimits: [\n            Math.min(\n                stats0.contrastLimits[0],\n                statsMid.contrastLimits[0],\n                statsTop.contrastLimits[0],\n            ),\n            Math.max(\n                stats0.contrastLimits[1],\n                statsMid.contrastLimits[1],\n                statsTop.contrastLimits[1],\n            ),\n        ],\n    };\n}\n\nexport async function getMultiSelectionStats(\n    loader,\n    selections = [{ c: 0, t: 0 }],\n) {\n    const stats = await Promise.all(\n        selections.map((selection) =>\n            getSingleSelectioStats3D(loader, selection),\n        ),\n    );\n    const domains = stats.map((stat) => stat.contrastLimits);\n    const contrastLimits = stats.map((stat) => stat.contrastLimits);\n    return { domains, contrastLimits };\n}\n\nexport function getDefaultSelectionStats(n) {\n    const domains = new Array(n).fill([0, 1000]);\n    const contrastLimits = domains;\n    //nb, not clear that adding _id here is necessarily ideal, seems to be working for now\n    //key for keeping track of multiple 'channels' with selections on the same 'c'.\n    const selections = new Array(n).fill().map((_, i) => {\n        return { c: i, t: 0, z: 0, _id: i };\n    });\n    const colors = getDefaultChannelColors(n);\n    const channelsVisible = new Array(n).fill(true);\n    return { domains, contrastLimits, selections, colors, channelsVisible };\n}\n\nexport function getDefaultChannelColors(n) {\n    if (n === 1) return [[255, 255, 255]];\n    return new Array(n).fill([0, 0, 0]).map((_, i) => {\n        //TODO: non-shit algorithm / use a nice palette.\n        const a = i / n;\n        return [Math.floor(a * 255), Math.floor((1 - a) * 255), 0];\n    });\n}\n\n/**\n * Get physical size scaling Matrix4\n * @param {Object} loader PixelSource\n */\nexport function getPhysicalSizeScalingMatrix(loader) {\n    const { x, y, z } = loader?.meta?.physicalSizes ?? {};\n    if (x?.size && y?.size && z?.size) {\n        const min = Math.min(z.size, x.size, y.size);\n        const ratio = [x.size / min, y.size / min, z.size / min];\n        return new Matrix4().scale(ratio);\n    }\n    return new Matrix4().identity();\n}\n\nexport function getBoundingCube(loader) {\n    const source = Array.isArray(loader) ? loader[0] : loader;\n    const { shape, labels } = source;\n    const physicalSizeScalingMatrix = getPhysicalSizeScalingMatrix(source);\n    const xSlice = [\n        0,\n        physicalSizeScalingMatrix[0] * shape[labels.indexOf(\"x\")],\n    ];\n    const ySlice = [\n        0,\n        physicalSizeScalingMatrix[5] * shape[labels.indexOf(\"y\")],\n    ];\n    const zSlice = [\n        0,\n        physicalSizeScalingMatrix[10] * shape[labels.indexOf(\"z\")],\n    ];\n    return [xSlice, ySlice, zSlice];\n}\n","import {\n    loadOmeTiff,\n    DetailView,\n    VolumeView,\n    ColorPaletteExtension,\n    ColorPalette3DExtensions,\n    DETAIL_VIEW_ID,\n    getChannelStats,\n} from \"@vivjs-experimental/viv\";\n\nimport { hexToRGB, RGBToHex } from \"../datastore/DataStore.js\";\nimport { Deck } from \"@deck.gl/core\";\nimport {\n    getMultiSelectionStats,\n    getDefaultSelectionStats,\n    getBoundingCube,\n} from \"../utilities/VivUtils.js\";\nimport { ScatterplotLayer } from \"deck.gl\";\nimport { getRandomString } from \"../utilities/Utilities\";\n\nconst tiffs = new Map();\nexport function acceptTiffCache(oldTiffs) {\n    console.log(\"accepting tiff cache\");\n    oldTiffs.forEach((tiff, key) => {\n        tiffs.set(key, tiff);\n    });\n}\nfunction getTiff(url) {\n    if (tiffs.has(url)) {\n        return tiffs.get(url);\n    }\n    const tiff = loadOmeTiff(url);\n    tiffs.set(url, tiff);\n    return tiff;\n}\n// if (module.hot) {\n//   module.hot.accept(newModule => {\n//     newModule.acceptTiffCache(tiffs);\n//   });\n// }\n\nclass VivViewerMDV {\n    constructor(canvas, config, initialView) {\n        console.log(\"new VivViewerMDV\", config);\n        this.canvas = canvas;\n        this.height = this.canvas.height;\n        this.width = this.canvas.width;\n        this.config = config;\n        this.hasRequestedDefaultChannelStats = false;\n        this.initClip();\n\n        getTiff(config.url)\n            .then((loader) => {\n                this.tiff = loader;\n                this._setUp(loader, initialView);\n            })\n            .catch((e) => {\n                console.log(e);\n                const ctx = this.canvas.getContext(\"2d\");\n                ctx.font = \"20px Arial\";\n                this.canvas\n                    .getContext(\"2d\")\n                    .fillText(\"Error loading data\", 10, 20);\n            });\n    }\n\n    setSize(x, y, conf) {\n        this.height = y;\n        this.width = x;\n\n        const v = this.getViewState(conf.x_scale, conf.y_scale, conf.offset);\n\n        this.detailView = new DetailView({\n            id: DETAIL_VIEW_ID,\n            height: y < this.native_y ? this.native_y : y,\n            width: x < this.native_x ? this.native_x : x,\n        });\n\n        const deckGLView = this.detailView.getDeckGlView();\n        this.canvas.width = x;\n        this.canvas.height = y;\n        this.canvas.style.width = x;\n        this.canvas.style.height = y;\n        this.deck.setProps({\n            height: y,\n            width: x,\n            viewState: v,\n            views: [deckGLView],\n        });\n    }\n\n    setPanZoom(offset, x_scale, y_scale) {\n        const v = this.getViewState(x_scale, y_scale, offset);\n        this.deck.setProps({\n            viewState: v,\n        });\n    }\n\n    getViewState(x_scale, y_scale, offset) {\n        // when rendering 3d, we want viewState to be undefined so it can use initialViewState & internal camera control\n        if (this.config.use3d) return undefined;\n        const hzoom = Math.log2(y_scale);\n        const wzoom = Math.log2(x_scale);\n        //need to make width and height th same as the canvas if they are smaller\n        //this is because the target is based on the width and height\n        const nx = this.width > this.native_x ? this.width : this.native_x;\n        const ny = this.height > this.native_y ? this.height : this.native_y;\n        let xpos = ((1 / x_scale) * nx) / 2;\n        xpos -= offset[0];\n        let ypos = ((1 / y_scale) * ny) / 2;\n        ypos += this.native_y - offset[1];\n        return {\n            height: nx,\n            width: ny,\n            id: DETAIL_VIEW_ID,\n            target: [xpos, ypos, 0],\n            zoom: [wzoom, hzoom],\n        };\n    }\n\n    setChannel(channel) {\n        const channels = this.mainVivLayer.props;\n        const i = channels.selections.findIndex((x) => x.id === channel.id);\n\n        channels.colors[i] = hexToRGB(channel.color);\n        channels.contrastLimits[i] = channel.contrastLimits;\n        channels.channelsVisible[i] = channel.channelsVisible;\n        if (channel.domains) channels.domains[i] = channel.domains;\n        this.layers = [...this.layers];\n        this.deck.setProps({\n            layers: this.layers,\n        });\n    }\n\n    removeChannel(channel) {\n        const chs = this.mainVivLayer.props;\n        const i = chs.selections.findIndex((sel) => sel.id === channel.id);\n        chs.colors.splice(i, 1);\n        chs.selections.splice(i, 1);\n        chs.contrastLimits.splice(i, 1);\n        chs.channelsVisible.splice(i, 1);\n        chs.domains.splice(i, 1);\n        this.createLayers(chs);\n        this.deck.setProps({\n            layers: [this.layers],\n        });\n    }\n\n    async addChannel(channel) {\n        const chs = this.mainVivLayer.props;\n        chs.channelsVisible.push(true);\n        channel.color = channel.color || \"#ff00ff\";\n        // pjt consider using helpers (now effectively doing this indirectly).\n        /// --> channel.contrastLimit was always undefined anway\n        // channel.contrastLimits = channel.contrastLimit || [20,100];\n        //if new channels are addded there are no default values -need to be calculated?\n        const sel = { z: 0, t: 0, c: channel.index };\n        const data = await this.getDefaultChannelValues([{ index: 0, sel }]);\n\n        channel.contrastLimits = data[0].stats.contrastLimits; //this.defaultContrastLimits[channel.index].slice(0);\n        channel.domains = data[0].stats.domain; //this.defaultDomains[channel.index].slice(0);\n        channel.channelsVisible = true;\n        chs.colors.push(hexToRGB(channel.color));\n        chs.contrastLimits.push(channel.contrastLimits);\n        chs.domains.push(channel.domains);\n        channel.id = getRandomString();\n        chs.selections.push({ ...sel, id: channel.id });\n\n        this.createLayers(chs);\n        this.deck.setProps({\n            layers: [this.layers],\n        });\n\n        channel.name = this.channels[channel.index].Name;\n        //channel._id = chs.selections[chs.selections.length-1]._id;\n        return channel;\n    }\n\n    /** equivalent to VivScatterPlot... */\n    getAllChannels() {\n        return this.channels;\n    }\n    getSelectedChannels() {\n        const { props } = this.mainVivLayer;\n        const names = props.selections.map((x) => this.channels[x.c].Name);\n        const colors = props.colors.map(RGBToHex);\n        return names.map((name, i) => {\n            return {\n                name,\n                index: props.selections[i].c,\n                id: props.selections[i].id,\n                color: colors[i],\n                contrastLimits: props.contrastLimits[i].slice(0),\n                channelsVisible: props.channelsVisible[i],\n                domains: props.domains[i],\n            };\n        });\n    }\n\n    recenterCamera() {\n        if (!this.config.use3d) return;\n        console.log(\"recenter\");\n        const { SizeX, SizeY, SizeZ } = this.tiff.metadata.Pixels;\n        const target = [SizeX / 2, SizeY / 2, SizeZ / 2];\n        const initialViewState = {\n            target,\n            zoom: 1,\n            rotationX: 0,\n            rotationOrbit: 0 + Math.random() * 0.01,\n        };\n        this.volViewState = initialViewState;\n        this.deck.setProps({\n            initialViewState,\n        });\n    }\n\n    _createLayers3D() {\n        const tiff = this.tiff;\n        //most of this can move into createLayers()\n        const {\n            SizeX,\n            SizeY,\n            SizeZ,\n            Channels: channels,\n        } = tiff.metadata.Pixels;\n        const target = [SizeX / 2, SizeY / 2, SizeZ / 2];\n        const id = `3d_${DETAIL_VIEW_ID}`;\n        const loader = tiff.data;\n        const n = channels.length;\n        // this is wrong in cases where non-default set of channels is used.\n        // const selections = channels.map((_, i) => {return {c: i, t: 0, z: 0}});\n        const dtype = tiff.data[0].dtype;\n        const { domains, contrastLimits, selections, colors, channelsVisible } =\n            this.newVivProps ??\n            (this.mainVivLayer\n                ? this.mainVivLayer.props\n                : getDefaultSelectionStats(n));\n        this.newVivProps = null;\n        if (!this.hasRequestedDefaultChannelStats) {\n            this.hasRequestedDefaultChannelStats = true;\n            this.defaultDomains = domains;\n            this.defaultContrastLimits = contrastLimits.slice(0);\n            getMultiSelectionStats(loader, selections).then((v) => {\n                this.defaultDomains = v.domains;\n                this.defaultContrastLimits = v.contrastLimits.slice(0);\n                this.newVivProps = { ...this.mainVivLayer.props, ...v };\n                this._updateProps();\n            });\n        }\n        const xSlice = this.getXSlice();\n        const ySlice = this.getYSlice();\n        const zSlice = this.getZSlice();\n        const resolution = loader.length - 1; // this should change...\n        const props = {\n            id,\n            loader,\n            dtype,\n            resolution,\n            channelsVisible,\n            contrastLimits,\n            domains,\n            selections,\n            colors,\n            xSlice,\n            ySlice,\n            zSlice,\n        };\n        const volumeView = this.detailView;\n        // could we setProps here instead when the layer already exists? no, don't think so - readonly.\n        const layers = volumeView.getLayers({\n            props,\n            viewStates: [this.volViewState],\n        });\n        this.layers = layers;\n        this.mainVivLayer = layers[0];\n        if (this.config.scatterData) {\n            // alert('scatter!');\n            layers.push(\n                new ScatterplotLayer({\n                    data: this.config.scatterData, //.slice(0), //do not want to clone / slice here... but mutating data doesn't work otherwise\n                    radiusScale: 1,\n                    billboard: true,\n                    getFillColor: this.config.getScatterFillColor,\n                    // getFillColor: (d) => d.color || [100, 100, 100]\n                }),\n            );\n        }\n    }\n\n    initClip() {\n        this.clipX = [0, 1];\n        this.clipY = [0, 1];\n        this.clipZ = [0, 1];\n    }\n    // so much boilerplate...\n    setClipX(min, max) {\n        this.clipX = [min, max];\n        this._updateProps();\n    }\n    setClipY(min, max) {\n        this.clipY = [min, max];\n        this._updateProps();\n    }\n    setClipZ(min, max) {\n        this.clipZ = [min, max];\n        this._updateProps();\n    }\n    getXSlice() {\n        const { SizeX } = this.tiff.metadata.Pixels;\n        const [min, max] = this.clipX;\n        // const v = NPOT(SizeX);\n        const v = getBoundingCube(this.loader)[0][1];\n        return [min * v, max * v];\n    }\n    getYSlice() {\n        const { SizeY } = this.tiff.metadata.Pixels;\n        const [min, max] = this.clipY;\n        // const v = NPOT(SizeY);\n        const v = getBoundingCube(this.loader)[1][1];\n        return [min * v, max * v];\n    }\n    getZSlice() {\n        const { SizeZ } = this.tiff.metadata.Pixels;\n        const [min, max] = this.clipZ;\n        // const v = NPOT(SizeZ);\n        const v = getBoundingCube(this.loader)[2][1];\n        return [min * v, max * v];\n    }\n    _updateProps() {\n        this.createLayers();\n        this.deck.setProps({ layers: this.layers });\n    }\n\n    //parses the config into internal data structure\n    //adding any missing values as necessary\n    _parseChannels(conf) {\n        const nconf = {\n            selections: [],\n            colors: [],\n            channelsVisible: [],\n            contrastLimits: [],\n            domains: [],\n        };\n        const def_colors = [\n            [0, 0, 255],\n            [0, 255, 0],\n            [255, 0, 0],\n            [255, 255, 0],\n            [0, 255, 255],\n            [255, 0, 255],\n        ];\n        let c_index = 0;\n        for (const item of conf) {\n            const chan = this.channels.findIndex((x) => x.Name === item.name);\n            if (chan === -1) {\n                console.warn(\n                    `channel '${item.name}' not found, uniforms housekeeping will be a bit messed up`,\n                );\n                continue;\n            }\n            nconf.selections.push({ z: 0, t: 0, c: chan });\n            let c = item.color;\n            c = c\n                ? typeof item.color === \"string\"\n                    ? hexToRGB(c)\n                    : c\n                : def_colors[c_index];\n            c_index++;\n            if (c_index >= def_colors.length) {\n                c_index = 0;\n            }\n            nconf.colors.push(c);\n            nconf.channelsVisible.push(\n                item.visible === undefined ? true : item.visible,\n            );\n            nconf.contrastLimits.push(item.contrastLimits || null);\n            nconf.domains.push(item.domains || null);\n        }\n        return nconf;\n    }\n\n    //get the channels in a nice format\n    getSelectedChannelsNice() {\n        const k = this.layers[0].props;\n        return k.selections.map((x, i) => {\n            return {\n                name: this.channels[x.c].Name,\n                color: k.colors[i],\n                visible: k.channelsVisible[i],\n                contrastLimits: k.contrastLimits[i],\n                domains: k.domains[i],\n            };\n        });\n    }\n\n    _setUp(loader, iv) {\n        this.native_x = loader.metadata.Pixels.SizeX;\n        this.native_y = loader.metadata.Pixels.SizeY;\n        const { use3d } = this.config;\n\n        this.extensions = [new ColorPaletteExtension()];\n        this.channels = loader.metadata.Pixels.Channels;\n        this.loader = loader.data;\n        this.transparentColor = [255, 255, 255, 0];\n        const baseViewState = this.getViewState(\n            iv.x_scale,\n            iv.y_scale,\n            iv.offset,\n        );\n\n        if (use3d) {\n            // this._setUpVolumeView(loader);\n            const { SizeX, SizeY, SizeZ } = loader.metadata.Pixels;\n            const target = [SizeX / 2, SizeY / 2, SizeZ / 2];\n            this.volViewState = {\n                zoom: 1,\n                target,\n            };\n            this.detailView = new VolumeView({\n                id: DETAIL_VIEW_ID,\n                useFixedAxis: false,\n                target,\n                extensions: [\n                    new ColorPalette3DExtensions.AdditiveBlendExtension(),\n                ],\n            });\n        } else {\n            this.detailView = new DetailView({\n                id: DETAIL_VIEW_ID,\n                height:\n                    this.native_y > this.height ? this.native_y : this.height,\n                width: this.native_x > this.width ? this.native_x : this.width,\n            });\n        }\n        const initialViewState = this.volViewState;\n        let { image_properties } = this.config;\n\n        const deckGLView = this.detailView.getDeckGlView();\n        //new more readable config\n        if (this.config.channels) {\n            image_properties = this._parseChannels(this.config.channels);\n        }\n        if (image_properties?.selections)\n            for (const s of image_properties.selections) {\n                s.id = getRandomString();\n            }\n        //check if there are any channels without contrast limits and get default values\n        const contrastLimitsToGet = [];\n        for (let n = 0; n < image_properties.contrastLimits.length; n++) {\n            if (\n                image_properties.contrastLimits[n] &&\n                image_properties.domains[n]\n            ) {\n                continue;\n            }\n            contrastLimitsToGet.push({\n                index: n,\n                sel: image_properties.selections[n],\n            });\n        }\n        //get the default values and continue the set up\n        this.getDefaultChannelValues(contrastLimitsToGet).then((data) => {\n            for (const d of data) {\n                image_properties.contrastLimits[d.index] =\n                    d.stats.contrastLimits;\n                image_properties.domains[d.index] = d.stats.domain;\n            }\n            this.createLayers(image_properties);\n            this.deck = new Deck({\n                canvas: this.canvas,\n                layers: [this.layers],\n                views: [deckGLView],\n                viewState: baseViewState,\n                width: this.width,\n                height: this.height,\n                useDevicePixels: true,\n                initialViewState,\n                controller: use3d,\n            });\n        });\n    }\n\n    //would be better to sample data that's loaded - but can't find\n    //a way of doing this. Also domainLimits seem way too large and for\n    //very low signals contrast limits are way too high\n    async getDefaultChannelValues(selections) {\n        return await Promise.all(\n            selections.map(async (s) => {\n                const data = await this.loader[\n                    this.loader.length - 1\n                ].getRaster({ selection: s.sel });\n                return { index: s.index, stats: getChannelStats(data.data) };\n            }),\n        );\n    }\n\n    createLayers(info) {\n        if (this.config.use3d) {\n            this._createLayers3D();\n            return;\n        }\n        const viewStates = { id: DETAIL_VIEW_ID };\n\n        //domains may not be the same as contrast limits -  again need way of calculating\n        //temp default values\n        const layerConfig = {\n            loader: this.loader,\n            contrastLimits: info.contrastLimits.slice(0),\n            domains: info.domains.slice(0),\n            colors: info.colors.slice(0),\n            channelsVisible: info.channelsVisible.slice(0),\n            selections: info.selections.slice(0),\n            extensions: this.extensions,\n            transparentColor: this.transparentColor,\n        };\n        if (!this.defaultDomains)\n            this.defaultDomains = layerConfig.contrastLimits; //PJT somewhat tested\n        if (!this.defaultContrastLimits)\n            this.defaultContrastLimits = this.defaultDomains.slice(0);\n        this.layers = this.detailView.getLayers({\n            viewStates,\n            props: layerConfig,\n        });\n        //scale bar layer not formatted correctly\n        this.layers = [this.layers[0]];\n        this.mainVivLayer = this.layers[0];\n    }\n}\n\nexport default VivViewerMDV;\n"],"names":["getSingleSelectioStats3D","loader","selection","c","t","lowResSource","length","shape","labels","sizeZ","indexOf","raster0","getRaster","z","rasterMid","Math","floor","rasterTop","max","stats0","getChannelStats","data","statsMid","statsTop","domain","min","contrastLimits","getMultiSelectionStats","selections","stats","Promise","all","map","domains","stat","getDefaultSelectionStats","n","Array","fill","_","i","_id","colors","getDefaultChannelColors","channelsVisible","a","getPhysicalSizeScalingMatrix","x","y","meta","physicalSizes","size","ratio","Matrix4","scale","identity","getBoundingCube","source","isArray","physicalSizeScalingMatrix","xSlice","ySlice","zSlice","tiffs","Map","getTiff","url","has","get","tiff","loadOmeTiff","set","VivViewerMDV","constructor","canvas","config","initialView","console","log","height","width","hasRequestedDefaultChannelStats","initClip","then","_setUp","catch","e","ctx","getContext","font","fillText","setSize","conf","v","getViewState","x_scale","y_scale","offset","detailView","DetailView","id","DETAIL_VIEW_ID","native_y","native_x","deckGLView","getDeckGlView","style","deck","setProps","viewState","views","setPanZoom","use3d","hzoom","log2","wzoom","nx","ny","xpos","ypos","target","zoom","setChannel","channel","channels","mainVivLayer","props","findIndex","hexToRGB","color","layers","removeChannel","chs","sel","splice","createLayers","addChannel","push","index","getDefaultChannelValues","getRandomString","name","Name","getAllChannels","getSelectedChannels","names","RGBToHex","slice","recenterCamera","SizeX","SizeY","SizeZ","metadata","Pixels","initialViewState","rotationX","rotationOrbit","random","volViewState","_createLayers3D","Channels","dtype","newVivProps","defaultDomains","defaultContrastLimits","_updateProps","getXSlice","getYSlice","getZSlice","resolution","getLayers","viewStates","scatterData","ScatterplotLayer","radiusScale","billboard","getFillColor","getScatterFillColor","clipX","clipY","clipZ","setClipX","setClipY","setClipZ","_parseChannels","nconf","def_colors","c_index","item","chan","warn","visible","undefined","getSelectedChannelsNice","k","iv","extensions","ColorPaletteExtension","transparentColor","baseViewState","VolumeView","useFixedAxis","ColorPalette3DExtensions","AdditiveBlendExtension","image_properties","s","contrastLimitsToGet","d","Deck","useDevicePixels","controller","info","layerConfig"],"mappings":"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"}