"""
Python binding for XDAQ Device
"""
from __future__ import annotations
import os
import typing
import typing_extensions
__all__ = ['DataStream', 'DataView', 'Device', 'DeviceManager', 'ManagedBuffer', 'ReturnCode', 'get_device_manager']
class DataStream:
    def __enter__(self) -> DataStream:
        ...
    def __exit__(self, arg0: type | None, arg1: typing.Any | None, arg2: typing.Any | None) -> None:
        ...
    def stop(self) -> None:
        ...
class DataView:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
class Device:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def get_info(self) -> str | None:
        ...
    def get_register(self, arg0: int) -> int:
        ...
    def get_register_sync(self, arg0: int) -> int | None:
        ...
    def get_status(self) -> str | None:
        ...
    def read(self, arg0: int, arg1: typing_extensions.Buffer) -> int:
        ...
    def read_registers(self) -> ReturnCode:
        ...
    def send_registers(self) -> ReturnCode:
        ...
    def set_register(self, arg0: int, arg1: int, arg2: int) -> ReturnCode:
        ...
    def set_register_sync(self, arg0: int, arg1: int, arg2: int) -> ReturnCode:
        ...
    def start_aligned_read_stream(self, addr: int, alignment: int, callback: typing.Callable[[DataView | None, str | None], None], *, chunk_size: int = 0, max_queue_elements: int = 4096) -> DataStream | None:
        ...
    def start_read_stream(self, addr: int, callback: typing.Callable[[ManagedBuffer | None, str | None], None], *, chunk_size: int = 0, max_queue_elements: int = 4096) -> DataStream | None:
        ...
    def trigger(self, arg0: int, arg1: int) -> ReturnCode:
        ...
    def write(self, arg0: int, arg1: typing_extensions.Buffer) -> int:
        ...
class DeviceManager:
    def create_device(self, arg0: str) -> Device:
        ...
    def get_device_options(self) -> str:
        ...
    def info(self) -> str:
        ...
    def list_devices(self) -> str:
        ...
    def location(self) -> os.PathLike:
        ...
class ManagedBuffer:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
class ReturnCode:
    """
    Members:
    
      Success
    
      Failure
    """
    Failure: typing.ClassVar[ReturnCode]  # value = <ReturnCode.Failure: 1>
    Success: typing.ClassVar[ReturnCode]  # value = <ReturnCode.Success: 0>
    __members__: typing.ClassVar[dict[str, ReturnCode]]  # value = {'Success': <ReturnCode.Success: 0>, 'Failure': <ReturnCode.Failure: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
def get_device_manager(arg0: os.PathLike) -> DeviceManager:
    ...
