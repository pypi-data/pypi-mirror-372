import itertools
from collections.abc import Iterable, Iterator, Sequence, Sized

from shouldersurfscore.classes.guessing_strategies import GuessingStrategy
from shouldersurfscore.classes.password_validator import PasswordValidator


class GuessManager(Iterable[str], Sized):
    """
    Facade facilitating access to guesses generated by one or more guessing strategies.

    For an instance `guesser`:

    The number of guesses can be obtained with `len(guesser)`
    or the `num_possible_guesses` property.

    Membership can be checked using the `in` operator: `"abc" in guesser`.

    An instance can also be directly iterated:
    >>> for guess in guesser:
    >>>     print(guess)

    The `num_guesses_made` and `history` properties will be reset
    everytime iteration is invoked.
    """

    def __init__(
        self,
        observed_guess: str,
        strategies: Sequence[GuessingStrategy],
        password_validator: PasswordValidator | None = None,
    ) -> None:
        """
        Initialize the manager with an observed guess, a list of strategies,
        and an optional password validator.<br>
        The password validator, if provided, will be used
        to filter the generated list of guesses.

        Parameters
        ----------
        observed_guess : str
            The observed guess.
        strategies : Sequence[GuessingStrategy]
            The list of strategies to generate guesses from.<br>
            Strategies are used in the order provided.<br>
            If a strategy produces a guess already produced by another strategy,
            it will be tossed out.
        password_validator : PasswordValidator | None, optional
            A `PasswordValidator` instance to filter the guesses with, by default None.
        """
        self._strategies: Sequence[GuessingStrategy] = strategies
        # Doing this instead of using `set_observed_guess()`
        # b/c it would needlessly generate the guess list twice
        # since `set_password_validator()` at the end will generate the list
        for strategy in self._strategies:
            strategy.observed_guess = observed_guess
        self._guesses: list[str] = []
        # For efficient duplicate prevention when generating guess list
        self._guess_set: set[str] = set()
        # For memoizing length since it is used every call to `__next__`
        self._length: int = 0
        # For iterable implementation
        self._i: int = 0
        # This call also generates the guess list
        self.set_password_validator(password_validator)

    def _generate_guess_list(self) -> None:
        """
        Iterate through guessing strategies to produce the guess list.<br>
        Duplicates and invalid passwords will be tossed out.
        """
        self._guesses = []
        self._guess_set = set()
        for guess in itertools.chain.from_iterable(self._strategies):
            if guess not in self._guess_set and self._password_validator.is_valid(
                guess
            ):
                self._guess_set.add(guess)
                self._guesses.append(guess)
        self._length = len(self._guesses)

    def __len__(self) -> int:
        return self._length

    def __iter__(self) -> Iterator[str]:
        self._i = 0
        return self

    def __next__(self) -> str:
        if self._i >= self._length:
            raise StopIteration
        guess: str = self._guesses[self._i]
        self._i += 1
        return guess

    def __contains__(self, guess: str) -> bool:
        return guess in self._guesses

    @property
    def num_guesses_made(self) -> int:
        """The number of guesses made since the start of the last iteration."""
        return self._i

    @property
    def num_possible_guesses(self) -> int:
        """The number of possible guesses, accounting for duplicates and invalid guesses."""
        return len(self)

    @property
    def history(self) -> list[str]:
        """The guesses produced since the start of the last iteration."""
        return self._guesses[0 : self._i]

    def set_observed_guess(self, observed_guess: str) -> None:
        """
        Update strategies with a new observed guess and regenerate the guess list.<br>
        Resets all properties.

        Parameters
        ----------
        observed_guess : str
            The new observed guess.
        """
        for strategy in self._strategies:
            strategy.observed_guess = observed_guess
        self._generate_guess_list()

    def set_password_validator(
        self, password_validator: PasswordValidator | None
    ) -> None:
        """
        Set the password validator used to filter out guesses.<br>
        Whenever this is called, the guess list will be regenerated
        and both `num_guesses_made` and `history` will be reset.

        Parameters
        ----------
        password_validator : PasswordValidator | None
            The new password validator to use.
        """
        self._password_validator: PasswordValidator = (
            password_validator if password_validator else PasswordValidator([])
        )
        # (Re)generate list with new password validator.
        self._generate_guess_list()

    def index(self, guess: str) -> int | None:
        """
        The list index of the given guess.

        Parameters
        ----------
        guess : str
            The guess to retrieve the index for.

        Returns
        -------
        int|None
            The index of `guess`, `None` if not present.
        """
        return self._guesses.index(guess) if guess in self._guesses else None
