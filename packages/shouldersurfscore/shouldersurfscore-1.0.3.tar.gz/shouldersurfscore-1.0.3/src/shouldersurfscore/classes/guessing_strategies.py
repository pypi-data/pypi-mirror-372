from __future__ import annotations

import abc
import itertools
from collections.abc import Callable, Iterable, Iterator
from functools import cached_property

from typing_extensions import override

from shouldersurfscore.classes.bounds import Bounds
from shouldersurfscore.classes.key import Key
from shouldersurfscore.classes.keyboard import Keyboard


class GuessIterator(Iterator[str]):
    """
    Iterator for iterating over the guesses generated by a `GuessingStrategy`.
    """

    def __init__(self, strategy: GuessingStrategy) -> None:
        """
        Initialize the iterator with a `GuessingStrategy` object.

        Parameters
        ----------
        strategy : GuessingStrategy
            The strategy to iterate over.
        """
        self._strategy: GuessingStrategy = strategy
        self._i = 0

    def __next__(self) -> str:
        """
        Returns guesses from a guessing strategy until exhausted.

        Returns
        -------
        str
            A guess from the guessing strategy.
        """
        if self._i >= len(self._strategy.guesses):
            raise StopIteration
        guess: str = self._strategy.guesses[self._i]
        self._i += 1
        return guess


class ObservedGuessNotSetError(Exception):
    """
    Exception raised when the observed guess property is accessed before having been set.
    """

    def __init__(self) -> None:
        super().__init__("Observed guess has not been set for this strategy.")


class GuessingStrategy(abc.ABC, Iterable[str]):
    """
    Interface for defining a password guessing strategy.<br>
    Implementers need only to define the following method:<br>
    `def _get_guesses(self) -> list[str]`

    The observed guess will be available through the `observed_guess` property.<br>
    Any other parameters that are needed should be passed in via the constructor.

    Examples
    -------
    >>> class ReversedStrategy(GuessingStrategy):
    >>>     @override
    >>>     def _get_guesses(self) -> list[str]:
    >>>         return [self.observed_guess[::-1]]
    >>>
    >>> class GuessListStrategy(GuessingStrategy):
    >>>     def __init__(self, guesses: list[str]) -> None:
    >>>         self._guesses: list[str] = guesses
    >>>
    >>>     @override
    >>>     def _get_guesses(self) -> list[str]:
    >>>         return self._guesses
    """

    @property
    def observed_guess(self) -> str:
        """The guess observed by the attacker."""
        # Doing this instead of setting a default
        # so as to avoid the interface having an `__init__`
        if not hasattr(self, "_observed_guess"):
            raise ObservedGuessNotSetError()
        return self._observed_guess

    @observed_guess.setter
    def observed_guess(self, observed_guess: str) -> None:
        """
        Set the observed guess for this instance.

        Parameters
        ----------
        observed_guess : str
            _description_
        """
        self._observed_guess: str = observed_guess
        # clear cached property
        if hasattr(self, "guesses"):
            del self.guesses

    @abc.abstractmethod
    def _get_guesses(self) -> list[str]:
        """
        Produces the sequence of guesses generated by this strategy.

        Returns
        -------
        list[str]
            The list of guesses.
        """

    # Accessing guesses this way so guessing can be cached
    # without relying on implementers to import functools
    # and decorate `_get_guesses()` with `cached_property`
    @cached_property
    def guesses(self) -> list[str]:
        """
        Public access to the guesses generated by this strategy.<br>
        This property is cached, so the list of guesses is only computed once.<br>
        If the `observed_guess` property is updated, the cache will be cleared.
        """
        return self._get_guesses()

    @override
    def __iter__(self) -> GuessIterator:
        return GuessIterator(self)


class ObservedGuess(GuessingStrategy):
    """
    Guessing strategy representing the password observed by an attacker.
    """

    @override
    def _get_guesses(self) -> list[str]:
        return [self.observed_guess]


class SwapAdjacentCharacters(GuessingStrategy):
    """
    Guessing strategy that swaps adjacent characters in a string.

    For example:
        If an attacker observed the password 'ABCD',
        this strategy will generate:
            'BACD',
            'ACBD',
            'ABDC'

    """

    @override
    def _get_guesses(self) -> list[str]:
        return [
            self.observed_guess[:i]
            + self.observed_guess[i + 1]
            + self.observed_guess[i]
            + self.observed_guess[i + 2 :]
            for i in range(len(self.observed_guess) - 1)
        ]


class SwapAdjacentKeys(GuessingStrategy):
    """
    Guessing strategy that swaps each character of an observed guess
    with characters from adjacent keys.

    If the observed guess is "ab", this strategy will produce:<br>
    "qb",<br>
    "wb",<br>
    "sb",<br>
    "xb",<br>
    "zb",<br>
    "av",<br>
    "af",<br>
    "ag",<br>
    "ah",<br>
    "an"<br>
    and optionally:<br>
    "Qb",<br>
    "Wb",<br>
    "Sb",<br>
    "Xb",<br>
    "Zb",<br>
    "aV",<br>
    "aF",<br>
    "aG",<br>
    "aH",<br>
    "aN".

    """

    def __init__(self, keyboard: Keyboard, include_shift_value: bool) -> None:
        """
        Initialize the strategy with the observed guess, keyboard being used,
        and whether to include the shift values from adjacent keys.

        Parameters
        ----------
        observed_guess : str
            The guess observed by the attacker.
        keyboard : Keyboard
            The keyboard used by the device being broken into.
        include_shift_value : bool
            Whether to include the shift value of adjacent keys.
        """
        self._keyboard: Keyboard = keyboard
        self._include_shift_value: bool = include_shift_value

    @property
    def _bounds(self) -> Bounds:
        """
        The bounding box that defines adjacent keys.<br>
        Can be overridden to specify a different adjacency set
        without needing to override `_get_guesses`.
        """
        return Bounds(-1, 1, 1, -1)

    @override
    def _get_guesses(self) -> list[str]:
        bounds: Bounds = self._bounds
        guesses: list[str] = []
        # Return a string that's the observed guess with the given character
        # subbed in at the given index
        # i.e. if the observed guess is "abc", `sub("r", 1)` returns "arc"
        sub: Callable[[str, int], str] = (
            lambda value, i: self.observed_guess[:i]
            + value
            + self.observed_guess[i + 1 :]
        )
        for i, ch in enumerate(self.observed_guess):
            keys: list[Key] = self._keyboard.get_keys_within_bounds_of_character(
                ch, bounds
            )
            for key in keys:
                guesses.append(sub(key.value, i))
                if self._include_shift_value and key.shift_value:
                    guesses.append(sub(key.shift_value, i))
        return guesses


class SwapHorizontallyAdjacentKeys(SwapAdjacentKeys):
    """
    Guessing strategy that swaps each character of an observed guess
    with characters from horizontally adjacent keys.
    """

    @property
    @override
    def _bounds(self) -> Bounds:
        return Bounds(-1, 0, 1, 0)


class SwapVerticallyAdjacentKeys(SwapAdjacentKeys):
    """
    Guessing strategy that swaps each character of an observed guess
    with characters from vertically adjacent keys.
    """

    @property
    @override
    def _bounds(self) -> Bounds:
        return Bounds(0, 1, 0, -1)


class BruteForceGuessing(GuessingStrategy):
    """
    Guessing strategy that generates all combinations of valid characters
    for each valid password length.
    """

    def __init__(self, characters: str, valid_lengths: list[int]) -> None:
        """
        Initialize the strategy with a character set and valid lengths.

        Parameters
        ----------
        characters : str
            The characters that can appear in the guess.
        valid_lengths : list[int]
            The valid lengths for guesses.
        """
        self._characters: str = characters
        self._valid_lengths: list[int] = valid_lengths

    @property
    @override
    def observed_guess(self) -> str:
        return super().observed_guess

    # overriding this property to remove cache deletion
    # and to avoid recomputing guesses
    # b/c it can be expensive and doesn't rely on the observed guess
    @observed_guess.setter
    @override
    def observed_guess(self, observed_guess: str) -> None:
        self._observed_guess: str = observed_guess

    @override
    def _get_guesses(self) -> list[str]:
        return [
            "".join(guess)
            for length in self._valid_lengths
            for guess in itertools.product(self._characters, repeat=length)
        ]

class BruteForceGuessByLength(GuessingStrategy):
    """
    Guessing strategy that generates all combinations of valid characters
    for the length of the observed password.
    """

    def __init__(self, characters: str, valid_lengths: list[int]) -> None:
        """
        Initialize the strategy with a character set and valid lengths.

        Parameters
        ----------
        characters : str
            The characters that can appear in the guess.
        valid_lengths : list[int]
            The valid lengths for guesses.
        """
        self._characters: str = characters
        self._valid_lengths: list[int] = valid_lengths

    @override
    def _get_guesses(self) -> list[str]:
        return [
            "".join(guess)
            for guess in itertools.product(self._characters, repeat=len(self.observed_guess))
        ]
