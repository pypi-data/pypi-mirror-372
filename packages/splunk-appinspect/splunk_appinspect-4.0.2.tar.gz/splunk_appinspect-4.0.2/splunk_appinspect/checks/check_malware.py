# Copyright 2019 Splunk Inc. All rights reserved.

"""
### Malware, viruses, malicious content, user security standards (static checks)
"""

import ipaddress
import logging
import platform
import re
from builtins import str as text
from pathlib import Path
from typing import TYPE_CHECKING

import splunk_appinspect
from splunk_appinspect.constants import Tags

if TYPE_CHECKING:
    from splunk_appinspect import App
    from splunk_appinspect.reporter import Reporter


logger = logging.getLogger(__name__)
report_display_order = 5


@splunk_appinspect.tags(
    Tags.SPLUNK_APPINSPECT,
    Tags.CLOUD,
    Tags.PRIVATE_APP,
    Tags.PRIVATE_VICTORIA,
    Tags.MIGRATION_VICTORIA,
    Tags.PRIVATE_CLASSIC,
)
def check_hostnames_and_ips(app: "App", reporter: "Reporter") -> None:
    """Check that no sensitive hostnames/IPs are stored in the app."""

    PUBLIC_DNS_LIST = [
        "208.67.222.222",
        "208.67.220.220",  # OpenDNS
        "1.1.1.1",
        "1.0.0.1",  # Cloudflare
        "8.8.8.8",
        "8.8.4.4",  # Google Public DNS
        "199.85.126.10",
        "199.85.127.10",  # Norton ConnectSafe
        "8.26.56.26",
        "8.20.247.20",  # Comodo Secure DNS
        "9.9.9.9",
        "149.112.112.112",  # Quad9
    ]
    SAFE_PRIVATE_IP_LIST = ["0.0.0.0", "127.0.0.1", "255.255.255.255"]

    results = app.search_for_pattern(
        "(^|[^\\d\\w\\.])(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})(?!/[1-3]?\\d($|[^\\d\\w\\.]))($|[^\\d\\w\\.])"
    )

    distinct_ip = {}
    for result in results:
        ip = result[1].groups()[1]
        address = None
        try:
            address = ipaddress.ip_address(text(ip))
        except ValueError:
            pass

        if address:
            filename, lineno = result[0].rsplit(":", 1)
            if address.is_loopback:
                continue
            if ip in SAFE_PRIVATE_IP_LIST or ip in PUBLIC_DNS_LIST:
                continue
            if re.search(
                "((requests|botocore|boto)/utils|scopes|socks|ipv4|dns/(query|resolver)|ipaddr|backports/socket|ipaddress(/__init__)?|ip/__init__)\\.py",
                filename,
            ):
                continue

            if distinct_ip.get(filename) is None:
                distinct_ip[filename] = set()

            if ip in distinct_ip[filename]:
                continue
            if len(distinct_ip[filename]) == 100:
                continue

            if address.is_global:
                ip_type = "PUBLIC"
            elif address.is_private:
                ip_type = "PRIVATE"
            elif address.is_reserved:
                ip_type = "RESERVED"
            elif address.is_multicast:
                ip_type = "MULTICASE"
            elif address.is_unspecified:
                ip_type = "UNSPECIFIED"
            else:
                ip_type = "UNKNOWN"

            distinct_ip[filename].add(ip)
            report = f"{ip_type} IP {ip} is found in {filename}:{lineno}"
            reporter.warn(report, filename, lineno)
