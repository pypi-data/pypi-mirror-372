# -*- coding: utf-8 -*-

"""
googlemapsplatformcoreapis

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""

from googlemapsplatformcoreapis.api_helper import APIHelper
from googlemapsplatformcoreapis.configuration import Server
from googlemapsplatformcoreapis.controllers.base_controller import BaseController
from apimatic_core.request_builder import RequestBuilder
from apimatic_core.response_handler import ResponseHandler
from apimatic_core.types.parameter import Parameter
from googlemapsplatformcoreapis.http.http_method_enum import HttpMethodEnum
from apimatic_core.authentication.multiple.single_auth import Single
from googlemapsplatformcoreapis.models.m_200_ok_36 import M200OK36
from googlemapsplatformcoreapis.models.m_200_ok_38 import M200OK38
from googlemapsplatformcoreapis.exceptions.m_400_badrequest_4_exception import M400BADREQUEST4Exception


class RoadsAPIController(BaseController):

    """A Controller to access Endpoints in the googlemapsplatformcoreapis API."""
    def __init__(self, config):
        super(RoadsAPIController, self).__init__(config)

    def snap_to_roads(self,
                      path,
                      accept):
        """Does a GET request to /snaptoroads.

        This service returns the best-fit road geometry for a given set of GPS
        coordinates. This service takes up to 100 GPS points collected along a
        route, and returns a similar set of data with the points snapped to
        the most likely roads the vehicle was traveling along. Optionally, you
        can request that the points be interpolated, resulting in a path that
        smoothly follows the geometry of the road.

        Args:
            path (str): (Required) The path to be snapped. The path parameter
                accepts a list of latitude/longitude pairs. Latitude and
                longitude values should be separated by commas. Coordinates
                should be separated by the pipe character: "|". For example:
                `path=60.170880,24.942795|60.170879,24.942796|60.170877,24.9427
                96`. <div class="note">Note: The snapping algorithm works best
                for points that are not too far apart. If you observe odd
                snapping behavior, try creating paths that have points closer
                together. To ensure the best snap-to-road quality, you should
                aim to provide paths on which consecutive pairs of points are
                within 300m of each other. This will also help in handling any
                isolated, long jumps between consecutive points caused by GPS
                signal loss, or noise.</div>
            accept (str): The request header parameter.

        Returns:
            M200OK36: Response from the API.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.SERVER_7)
            .path('/snaptoroads')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('path')
                         .value(path))
            .header_param(Parameter()
                          .key('Accept')
                          .value(accept))
            .auth(Single('apiKey'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(M200OK36.from_dictionary)
        ).execute()

    def nearest_roads(self,
                      points,
                      accept):
        """Does a GET request to /nearestRoads.

        This service returns individual road segments for a given set of GPS
        coordinates. This services takes up to 100 GPS points and returns the
        closest road segment for each point. The points passed do not need to
        be part of a continuous path.

        Args:
            points (str): (Required) The path to be snapped. The path
                parameter accepts a list of latitude/longitude pairs. Latitude
                and longitude values should be separated by commas.
                Coordinates should be separated by the pipe character: "|".
                For example:
                `path=60.170880,24.942795|60.170879,24.942796|60.170877,24.9427
                96`. <div class="note">Note: The snapping algorithm works best
                for points that are not too far apart. If you observe odd
                snapping behavior, try creating paths that have points closer
                together. To ensure the best snap-to-road quality, you should
                aim to provide paths on which consecutive pairs of points are
                within 300m of each other. This will also help in handling any
                isolated, long jumps between consecutive points caused by GPS
                signal loss, or noise.</div>
            accept (str): The request header parameter.

        Returns:
            M200OK38: Response from the API.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.SERVER_7)
            .path('/nearestRoads')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('points')
                         .value(points))
            .header_param(Parameter()
                          .key('Accept')
                          .value(accept))
            .auth(Single('apiKey'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(M200OK38.from_dictionary)
            .local_error('400', 'Bad Request', M400BADREQUEST4Exception)
        ).execute()
