#
# Copyright (C) 2025 CERN.
#
# chATLAS_Embed is free software; you can redistribute it and/or modify
# it under the terms of the Apache 2.0 license; see LICENSE file for more details.
# `chATLAS_Embed/LangChainVectorStore.py`

"""Wrapper for vector store to be compatible with langchain."""

import asyncio
import inspect

from langchain_core.callbacks import CallbackManagerForRetrieverRun
from langchain_core.documents import Document as LangchainDocument
from langchain_core.retrievers import BaseRetriever
from pydantic import BaseModel, ConfigDict, Field

from chATLAS_Embed.Base import VectorStore


class LangChainVectorStore(BaseRetriever, BaseModel):
    """
    Adapter for using a custom VectorStore store with LangChain.
    **NOTE**: Not all methods and features of langchain/langgraph currently supported.

    You can call invoke on the retriever or as part of a chain with metadata filters:
    ```
    docs = db_langchain.invoke("What is ATLAS?", config={"metadata": {"k": 2, "date_filter": "01-10-2020"}})
    ```
    **NOTE**: This only returns the parent documents, not their corresponding child documents.
    Similarity scores for the retrieval can be found in the returned doc metadata:
    ```
    [doc.metadata["similarity"] for doc in docs]
    ```

    Inputs:
    vector_store: VectorStore - Postgres vectorstore
    """

    vector_store: VectorStore = Field(..., description="The underlying vector store instance.")

    model_config = ConfigDict(arbitrary_types_allowed=True)

    def search(self, query: str, k: int = 4, metadata_filters: dict | None = None) -> list[LangchainDocument]:
        """Search and return documents in LangChain-compatible format.

        :param query: (str) - Input query to search vectorstore with
        :param k: (int) - Number of documents to return
        :param metadata_filters: (dict) - Dictionary of metadata filters where keys are metadata fields and values are
            filter values. can contain key: date_filter (str): A date string (e.g., '03-04-2010') to
            filter 'last_modification' for newer entries.

        :return:
        Search Results: (List[LangchainDocument])
        """

        # Need to make sure we don't affect input metadata
        metadata_filters_copy = metadata_filters.copy() if metadata_filters is not None else {}

        # Extract date_filter from metadata filters
        date_filter = metadata_filters_copy.get("date_filter")
        if date_filter:
            del metadata_filters_copy["date_filter"]

        # Extract k value from metadata filters
        k = metadata_filters_copy.pop("k", k)

        k_text = metadata_filters_copy.pop("k_text", 0)

        # Try int conversion
        try:
            k = int(k)
            k_text = int(k_text)
        except ValueError:
            print("Please give k values as ether ints or int parse-able strings")
            raise

        search_kwargs = {
            "metadata_filters": metadata_filters_copy,
            "date_filter": date_filter,
        }

        # This is a hacky way of doing this and should be changed!!

        # Get the function signature
        sig = inspect.signature(self.vector_store.search)

        # Extract the function's parameters
        params = sig.parameters

        # Check if 'k_text' is a keyword argument
        if "k_text" in params and params["k_text"].default is not inspect.Parameter.empty:
            search_kwargs["k_text"] = k_text

        results = self.vector_store.search(query, k, **search_kwargs)  # Returns List[(child, parent, score)]
        formatted_results = []

        for _child_doc, parent_doc, similarity in results:
            # Combine child and parent metadata for context if needed

            # Adding parent metadata including new required fields
            metadata = {}
            for key, val in parent_doc.metadata.items():
                metadata[key] = val
            metadata["source"] = parent_doc.source.value
            metadata["name"] = parent_doc.name
            metadata["url"] = parent_doc.url
            metadata["similarity"] = similarity

            langchain_formatted_doc = LangchainDocument(page_content=parent_doc.page_content, metadata=metadata)
            formatted_results.append(langchain_formatted_doc)

        return formatted_results

    async def _aget_relevant_documents(
        self, query: str, run_manager: CallbackManagerForRetrieverRun | None = None
    ) -> list[LangchainDocument]:
        """Retrieve relevant documents asynchronously.

        :param query: (str) - Input query to search vectorstore with
        :param run_manager: (CallbackManagerForRetrieverRun) - Autogenerated and passed in by langchain

        :return:
        Search Results: (List[LangchainDocument])
        """

        # Adaptation to work with langchain
        if run_manager is not None and "search_kwargs" in run_manager.metadata:
            input_metadata = run_manager.metadata["search_kwargs"]
        elif run_manager is not None:
            input_metadata = {k: v for k, v in run_manager.metadata.items() if not k.startswith("ls_")}
        else:
            input_metadata = {}

        # Define a wrapper for `self.search`
        def search_wrapper():
            return self.search(query=query, k=4, metadata_filters=input_metadata)

        return await asyncio.to_thread(search_wrapper)

    def _get_relevant_documents(
        self, query: str, *, run_manager: CallbackManagerForRetrieverRun
    ) -> list[LangchainDocument]:
        """Retrieve relevant documents asynchronously.

        :param query: (str) - Input query to search vectorstore with
        :param run_manager: (CallbackManagerForRetrieverRun) - Autogenerated and passed in by langchain

        :return:
        Search Results: (List[LangchainDocument])
        """

        # Adaptation to work with langchain
        if "search_kwargs" in run_manager.metadata:
            input_metadata = run_manager.metadata["search_kwargs"]
        else:
            input_metadata = {k: v for k, v in run_manager.metadata.items() if not k.startswith("ls_")}
        return self.search(query, k=4, metadata_filters=input_metadata)
