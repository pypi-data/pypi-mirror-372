"""
执行引擎 (ExecutionEngine)
Execution Engine
This module handles the execution of execution plans generated by the function router.
It coordinates between different modules and implements graceful degradation.
"""
from typing import Dict, Any, Optional, List, Union
import logging
import asyncio
import datetime
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger(__name__)

class ExecutionStatus(Enum):
    """执行状态枚举"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    DEGRADED = "degraded"

@dataclass
class ExecutionResult:
    """执行结果"""
    status: ExecutionStatus
    result: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None
    execution_time: float = 0.0
    modules_used: List[str] = field(default_factory=list)
    degradation_applied: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: str = field(default_factory=lambda: datetime.datetime.now().isoformat())
    
    def is_successful(self) -> bool:
        """检查执行是否成功"""
        return self.status in [ExecutionStatus.COMPLETED, ExecutionStatus.DEGRADED]
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            "status": self.status.value,
            "result": self.result,
            "error": self.error,
            "execution_time": self.execution_time,
            "modules_used": self.modules_used,
            "degradation_applied": self.degradation_applied,
            "metadata": self.metadata,
            "created_at": self.created_at
        }

class ExecutionEngine:
    """
    执行引擎
    
    负责执行由功能路由器生成的执行计划。
    支持模块组合、增强功能和优雅降级机制。
    """
    
    def __init__(self, module_manager):
        """
        初始化执行引擎
        
        Args:
            module_manager: 模块管理器实例
        """
        self.module_manager = module_manager
        
        # 执行统计
        self._execution_stats = {
            "total_executions": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "degraded_executions": 0,
            "avg_execution_time": 0.0,
            "module_usage": {}
        }
        
        # 执行历史
        self._execution_history: List[ExecutionResult] = []
        
        logger.info("Execution engine initialized successfully")
    
    async def execute_plan(self, execution_plan, context: Optional[Dict[str, Any]] = None) -> ExecutionResult:
        """
        执行执行计划
        
        Args:
            execution_plan: 执行计划对象
            context: 执行上下文
            
        Returns:
            ExecutionResult: 执行结果
        """
        start_time = datetime.datetime.now()
        context = context or {}
        
        try:
            logger.info(f"Starting execution: mode={execution_plan.mode.value}, primary_module={execution_plan.primary_module}")
            
            # 检查模块可用性
            available_modules = self._check_module_availability(execution_plan)
            
            # 如果主模块不可用，尝试降级
            if execution_plan.primary_module not in available_modules:
                if execution_plan.fallback_plan:
                    logger.warning(f"Primary module {execution_plan.primary_module} unavailable, using fallback plan")
                    return await self.execute_plan(execution_plan.fallback_plan, context)
                else:
                    return self._create_error_result(
                        f"Primary module {execution_plan.primary_module} is not available",
                        start_time
                    )
            
            # 执行计划
            result = await self._execute_with_modules(execution_plan, available_modules, context)
            
            # 记录统计信息
            execution_time = (datetime.datetime.now() - start_time).total_seconds()
            result.execution_time = execution_time
            
            self._update_execution_stats(result)
            self._execution_history.append(result)
            
            # 限制历史记录数量
            if len(self._execution_history) > 100:
                self._execution_history.pop(0)
            
            logger.info(f"Execution completed: status={result.status.value}, time={execution_time:.3f}s")
            return result
            
        except Exception as e:
            logger.error(f"Execution failed: {e}")
            execution_time = (datetime.datetime.now() - start_time).total_seconds()
            error_result = self._create_error_result(str(e), start_time)
            error_result.execution_time = execution_time
            
            self._update_execution_stats(error_result)
            self._execution_history.append(error_result)
            
            return error_result
    
    async def _execute_with_modules(self, execution_plan, available_modules: List[str], context: Dict[str, Any]) -> ExecutionResult:
        """
        使用可用模块执行计划
        
        Args:
            execution_plan: 执行计划
            available_modules: 可用模块列表
            context: 执行上下文
            
        Returns:
            ExecutionResult: 执行结果
        """
        modules_used = []
        degradation_applied = False
        
        # 获取主模块
        primary_module = self.module_manager.get_module(execution_plan.primary_module)
        if not primary_module or not primary_module.is_available():
            raise RuntimeError(f"Primary module {execution_plan.primary_module} is not available")
        
        modules_used.append(execution_plan.primary_module)
        
        # 检查增强模块
        enhancement_modules = []
        for module_name in execution_plan.enhancement_modules:
            module = self.module_manager.get_module(module_name)
            if module and module.is_available():
                enhancement_modules.append(module)
                modules_used.append(module_name)
            else:
                logger.warning(f"Enhancement module {module_name} is not available, applying degradation")
                degradation_applied = True
        
        # 执行主要功能
        tool_name = execution_plan.metadata.get("tool_name", "unknown")
        parameters = execution_plan.parameters
        
        # 根据工具名称调用相应的模块方法
        result = await self._call_module_method(primary_module, tool_name, parameters, context)
        
        # 应用增强功能
        if enhancement_modules:
            result = await self._apply_enhancements(result, enhancement_modules, execution_plan, context)
        
        # 创建执行结果
        status = ExecutionStatus.DEGRADED if degradation_applied else ExecutionStatus.COMPLETED
        
        return ExecutionResult(
            status=status,
            result=result,
            modules_used=modules_used,
            degradation_applied=degradation_applied,
            metadata={
                "execution_plan_mode": execution_plan.mode.value,
                "tool_name": tool_name,
                "enhancement_modules_requested": execution_plan.enhancement_modules,
                "enhancement_modules_used": [m.get_module_name() for m in enhancement_modules]
            }
        )
    
    async def _call_module_method(self, module, tool_name: str, parameters: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """
        调用模块方法
        
        Args:
            module: 模块实例
            tool_name: 工具名称
            parameters: 参数
            context: 上下文
            
        Returns:
            Dict[str, Any]: 执行结果
        """
        # 根据工具名称映射到模块方法
        method_mapping = {
            # 核心工具
            "aceflow_init": "aceflow_init",
            "aceflow_stage": "aceflow_stage", 
            "aceflow_validate": "aceflow_validate",
            
            # 协作工具
            "aceflow_respond": "aceflow_respond",
            "aceflow_collaboration_status": "aceflow_collaboration_status",
            "aceflow_task_execute": "aceflow_task_execute",
            
            # 智能工具
            "aceflow_intent_analyze": "aceflow_intent_analyze",
            "aceflow_recommend": "aceflow_recommend"
        }
        
        method_name = method_mapping.get(tool_name)
        if not method_name:
            raise ValueError(f"Unknown tool: {tool_name}")
        
        # 检查模块是否有该方法
        if not hasattr(module, method_name):
            raise AttributeError(f"Module {module.get_module_name()} does not have method {method_name}")
        
        # 调用方法
        method = getattr(module, method_name)
        
        # 准备参数
        call_args = parameters.copy()
        if context:
            call_args.update(context)
        
        # 调用方法（支持同步和异步）
        if asyncio.iscoroutinefunction(method):
            return await method(**call_args)
        else:
            return method(**call_args)
    
    async def _apply_enhancements(self, base_result: Dict[str, Any], enhancement_modules: List, execution_plan, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        应用增强功能
        
        Args:
            base_result: 基础执行结果
            enhancement_modules: 增强模块列表
            execution_plan: 执行计划
            context: 执行上下文
            
        Returns:
            Dict[str, Any]: 增强后的结果
        """
        enhanced_result = base_result.copy()
        tool_name = execution_plan.metadata.get("tool_name", "unknown")
        
        for module in enhancement_modules:
            module_name = module.get_module_name()
            
            try:
                if module_name == "collaboration":
                    enhanced_result = await self._apply_collaboration_enhancement(
                        enhanced_result, module, tool_name, execution_plan, context
                    )
                elif module_name == "intelligence":
                    enhanced_result = await self._apply_intelligence_enhancement(
                        enhanced_result, module, tool_name, execution_plan, context
                    )
                else:
                    logger.warning(f"Unknown enhancement module: {module_name}")
                
            except Exception as e:
                logger.error(f"Enhancement failed for module {module_name}: {e}")
                # 继续执行，不因增强失败而中断
        
        return enhanced_result
    
    async def _apply_collaboration_enhancement(self, result: Dict[str, Any], collab_module, tool_name: str, execution_plan, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用协作增强"""
        enhanced_result = result.copy()
        
        # 添加协作相关的增强信息
        if not enhanced_result.get("collaboration"):
            enhanced_result["collaboration"] = {}
        
        # 检查是否需要用户确认
        parameters = execution_plan.parameters
        if not parameters.get("auto_confirm", True):
            enhanced_result["collaboration"]["requires_confirmation"] = True
            enhanced_result["collaboration"]["confirmation_message"] = f"Please confirm the {tool_name} operation"
        
        # 添加协作状态
        try:
            collab_status = collab_module.aceflow_collaboration_status()
            if collab_status.get("success"):
                enhanced_result["collaboration"]["status"] = collab_status.get("collaboration_status", {})
        except Exception as e:
            logger.warning(f"Failed to get collaboration status: {e}")
        
        # 添加交互建议
        if parameters.get("user_input"):
            enhanced_result["collaboration"]["interaction_suggestions"] = [
                "Consider using collaborative review for this operation",
                "User input detected - collaboration features available"
            ]
        
        return enhanced_result
    
    async def _apply_intelligence_enhancement(self, result: Dict[str, Any], intel_module, tool_name: str, execution_plan, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用智能增强"""
        enhanced_result = result.copy()
        
        # 添加智能相关的增强信息
        if not enhanced_result.get("intelligence"):
            enhanced_result["intelligence"] = {}
        
        parameters = execution_plan.parameters
        
        # 如果有用户输入，进行意图分析
        if parameters.get("user_input"):
            try:
                intent_result = intel_module.aceflow_intent_analyze(
                    user_input=parameters["user_input"],
                    context=context
                )
                if intent_result.get("success"):
                    enhanced_result["intelligence"]["intent_analysis"] = intent_result.get("analysis_result", {})
            except Exception as e:
                logger.warning(f"Intent analysis failed: {e}")
        
        # 生成智能推荐
        try:
            recommendations = intel_module.aceflow_recommend(context=context)
            if recommendations.get("success"):
                enhanced_result["intelligence"]["recommendations"] = recommendations.get("recommendation_result", {})
        except Exception as e:
            logger.warning(f"Recommendation generation failed: {e}")
        
        # 添加智能提示
        if tool_name in ["aceflow_init", "aceflow_stage", "aceflow_validate"]:
            enhanced_result["intelligence"]["smart_suggestions"] = [
                f"Consider using advanced features for {tool_name}",
                "AI-powered insights available for this operation"
            ]
        
        return enhanced_result
    
    def _check_module_availability(self, execution_plan) -> List[str]:
        """
        检查模块可用性
        
        Args:
            execution_plan: 执行计划
            
        Returns:
            List[str]: 可用模块列表
        """
        available_modules = []
        
        # 检查主模块
        primary_module = self.module_manager.get_module(execution_plan.primary_module)
        if primary_module and primary_module.is_available():
            available_modules.append(execution_plan.primary_module)
        
        # 检查增强模块
        for module_name in execution_plan.enhancement_modules:
            module = self.module_manager.get_module(module_name)
            if module and module.is_available():
                available_modules.append(module_name)
        
        return available_modules
    
    def _create_error_result(self, error_message: str, start_time: datetime.datetime) -> ExecutionResult:
        """创建错误结果"""
        return ExecutionResult(
            status=ExecutionStatus.FAILED,
            error=error_message,
            execution_time=(datetime.datetime.now() - start_time).total_seconds(),
            metadata={"error_type": "execution_error"}
        )
    
    def _update_execution_stats(self, result: ExecutionResult):
        """更新执行统计信息"""
        self._execution_stats["total_executions"] += 1
        
        if result.status == ExecutionStatus.COMPLETED:
            self._execution_stats["successful_executions"] += 1
        elif result.status == ExecutionStatus.DEGRADED:
            self._execution_stats["degraded_executions"] += 1
        elif result.status == ExecutionStatus.FAILED:
            self._execution_stats["failed_executions"] += 1
        
        # 更新平均执行时间
        total_time = self._execution_stats["avg_execution_time"] * (self._execution_stats["total_executions"] - 1)
        total_time += result.execution_time
        self._execution_stats["avg_execution_time"] = total_time / self._execution_stats["total_executions"]
        
        # 更新模块使用统计
        for module_name in result.modules_used:
            if module_name not in self._execution_stats["module_usage"]:
                self._execution_stats["module_usage"][module_name] = 0
            self._execution_stats["module_usage"][module_name] += 1
    
    def get_execution_stats(self) -> Dict[str, Any]:
        """获取执行统计信息"""
        stats = self._execution_stats.copy()
        
        # 计算成功率
        total = stats["total_executions"]
        if total > 0:
            stats["success_rate"] = (stats["successful_executions"] + stats["degraded_executions"]) / total
            stats["failure_rate"] = stats["failed_executions"] / total
            stats["degradation_rate"] = stats["degraded_executions"] / total
        else:
            stats["success_rate"] = 0.0
            stats["failure_rate"] = 0.0
            stats["degradation_rate"] = 0.0
        
        return stats
    
    def get_execution_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """获取执行历史"""
        recent_history = self._execution_history[-limit:] if limit > 0 else self._execution_history
        return [result.to_dict() for result in recent_history]
    
    def reset_stats(self):
        """重置统计信息"""
        self._execution_stats = {
            "total_executions": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "degraded_executions": 0,
            "avg_execution_time": 0.0,
            "module_usage": {}
        }
        self._execution_history.clear()
        logger.info("Execution statistics reset")
    
    def get_health_status(self) -> Dict[str, Any]:
        """获取执行引擎健康状态"""
        stats = self.get_execution_stats()
        
        # 判断健康状态
        healthy = True
        issues = []
        
        if stats["total_executions"] > 0:
            if stats["failure_rate"] > 0.2:  # 失败率超过20%
                healthy = False
                issues.append("High failure rate")
            
            if stats["degradation_rate"] > 0.5:  # 降级率超过50%
                healthy = False
                issues.append("High degradation rate")
            
            if stats["avg_execution_time"] > 10.0:  # 平均执行时间超过10秒
                healthy = False
                issues.append("High execution time")
        
        return {
            "healthy": healthy,
            "issues": issues,
            "statistics": stats,
            "module_manager_healthy": self.module_manager is not None
        }